<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REVO - Advanced Combat</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@1,900&display=swap');
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Montserrat', sans-serif; user-select: none; }
        canvas { display: block; }

        /* MULTIPLAYER LOADING SCREEN */
        #loading-screen {
            position: absolute; z-index: 9999; top: 0; left: 0; width: 100%; height: 100%;
            background: #0a0a0a; display: none; flex-direction: column; align-items: center; justify-content: center;
            color: white; font-style: italic; font-weight: 900; font-size: 2rem;
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
        }
        .spinner {
            width: 60px; height: 60px; border: 6px solid #333; border-top: 6px solid #ff007f;
            border-radius: 50%; animation: spin 1s linear infinite; margin-top: 30px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* NETWORK CONNECTION INDICATOR */
        #network-status {
            position: absolute; top: 15px; right: 20px; z-index: 250;
            font-size: 0.9rem; color: #ffcc00; font-weight: bold; background: rgba(0,0,0,0.8);
            padding: 8px 15px; border-radius: 5px; border: 1px solid #ffcc00; display: none;
            letter-spacing: 1px; transition: 0.3s;
        }

        #map-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
            z-index: 210; display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white;
        }
        .map-cards { display: flex; gap: 20px; margin-top: 30px; flex-wrap: wrap; justify-content: center;}
        .map-card {
            background: #222; border: 2px solid #444; padding: 20px; border-radius: 10px; cursor: pointer;
            width: 200px; text-align: center; transition: 0.2s;
        }
        .map-card:hover { border-color: #ff007f; transform: scale(1.05); }
        .map-card.selected { border-color: #00ffcc; box-shadow: 0 0 20px rgba(0, 255, 204, 0.4); }

        #selection-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%);
            z-index: 200; display: none; flex-direction: column; align-items: center; justify-content: flex-start;
            color: white; padding-top: 40px;
        }

        h1 { font-style: italic; font-size: 3rem; margin: 0; text-shadow: 0 0 10px #ff007f; text-transform: uppercase; }
        .sub-text { margin-bottom: 30px; color: #888; letter-spacing: 2px; font-size: 0.8rem; }

        .loadout-container {
            display: flex; gap: 20px; padding: 20px; background: rgba(255,255,255,0.05);
            border-radius: 15px; backdrop-filter: blur(10px); border: 1px solid #333;
            max-width: 90%; overflow-x: auto;
        }

        .category-column { display: flex; flex-direction: column; align-items: center; min-width: 200px; }
        .category-title { background: #ff007f; color: white; padding: 5px 15px; transform: skewX(-15deg); font-size: 0.9rem; margin-bottom: 15px; box-shadow: 0 0 10px rgba(255, 0, 127, 0.5); }

        .item-list { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; max-height: 400px; overflow-y: auto; padding: 5px; width: 100%; }

        .item-btn {
            background: linear-gradient(135deg, #222, #111); border: 2px solid #333; color: #aaa; aspect-ratio: 1/1;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.2s; border-radius: 8px; font-size: 0.65rem; text-align: center; padding: 5px; position: relative; overflow: hidden;
        }
        .item-btn::before { content: ''; width: 40px; height: 40px; background: rgba(255,255,255,0.1); border-radius: 50%; margin-bottom: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        .item-btn:hover { background: #333; border-color: #666; transform: translateY(-2px); }
        .item-btn.selected { border-color: #ff007f; background: linear-gradient(135deg, rgba(255, 0, 127, 0.2), #111); color: white; box-shadow: 0 0 15px rgba(255,0,127,0.3); }

        #deploy-btn {
            margin-top: 30px; padding: 15px 80px; font-size: 1.5rem; background: #ff007f; color: white;
            border: none; cursor: pointer; transform: skewX(-15deg); font-weight: 900; box-shadow: 0 0 30px rgba(255,0,127,0.4); transition: 0.3s;
        }
        #deploy-btn:hover { transform: skewX(-15deg) scale(1.05); background: #ff3399; }
        #deploy-btn:disabled { background: #333; cursor: not-allowed; box-shadow: none; opacity: 0.5; }

        /* --- GAME UI --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: none; }
        
        #versus-hud {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; align-items: center;
            background: rgba(0,0,0,0.8); border: 2px solid #333; border-radius: 10px; padding: 10px 20px;
        }
        .vs-score { font-size: 2rem; font-weight: 900; width: 50px; text-align: center; }
        #p-score { color: #00ffcc; text-shadow: 0 0 10px #00ffcc; }
        #e-score { color: #ff007f; text-shadow: 0 0 10px #ff007f; }
        #match-timer { font-size: 1.5rem; color: white; background: #222; padding: 5px 15px; border-radius: 5px; }
        
        #round-announcement {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
            font-size: 4rem; color: white; font-style: italic; font-weight: 900;
            text-shadow: 0 0 20px #ff007f; opacity: 0; transition: opacity 0.5s; z-index: 100; text-align: center;
        }

        #flash-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; transition: opacity 0.1s; pointer-events: none; z-index: 999; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 24px; height: 24px; }
        .ch-bar { position: absolute; background: #ff0000; border: 1px solid #000; border-radius: 1px;}
        .ch-v { width: 4px; height: 10px; } .ch-h { width: 10px; height: 4px; }
        .ch-top { top: 0; left: 10px; } .ch-bottom { bottom: 0; left: 10px; } .ch-left { left: 0; top: 10px; } .ch-right { right: 0; top: 10px; }
        
        .ammo-display { position: absolute; bottom: 80px; left: 45px; color: white; font-size: 24px; text-shadow: 2px 2px black; font-style: italic; }
        .health-bar { position: absolute; bottom: 40px; left: 40px; width: 350px; height: 22px; background: rgba(0,0,0,0.6); border: 3px solid #000; transform: skewX(-15deg); overflow: hidden; border-radius: 2px; }
        .health-fill { width: 100%; height: 100%; background: #4efc03; box-shadow: inset 0 0 10px rgba(0,0,0,0.5); transition: width 0.2s; }
        .weapon-slots { position: absolute; bottom: 40px; right: 40px; display: flex; gap: 12px; }
        .slot { width: 70px; height: 70px; background: rgba(10,10,10,0.9); border: 2px solid #222; border-radius: 4px; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; color: white; font-size: 0.7rem; text-align: center; padding: 5px; box-sizing: border-box;}
        .slot.active { border-color: #ff007f; background: rgba(255,0,127,0.15); transform: scale(1.1); box-shadow: 0 0 15px rgba(255,0,127,0.3); }
        .slot::after { content: attr(data-key); position: absolute; top: 2px; left: 6px; color: #ff007f; font-size: 11px; font-weight: 900; }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div id="loading-msg">INITIALIZING SYSTEMS...</div>
        <div class="spinner"></div>
    </div>

    <div id="network-status">STATUS: OFFLINE</div>

    <div id="map-screen">
        <h1 id="map-header">SELECT ARENA</h1>
        <div class="map-cards" id="map-cards-container">
            <div class="map-card" data-map="Playground"><h3>The Playground</h3><p>High-Contrast Plastic</p></div>
            <div class="map-card" data-map="SkyPort"><h3>Sky Port</h3><p>Clean White/Minimalist</p></div>
            <div class="map-card" data-map="Construction"><h3>Construction Site</h3><p>High Altitude Danger</p></div>
            <div class="map-card" data-map="Container"><h3>Container Yard</h3><p>Classic Roblox FPS</p></div>
            <div class="map-card" data-map="Random" style="border-color: #ffd700;"><h3>Random Arena</h3><p>Let Fate Decide</p></div>
        </div>
    </div>

    <div id="selection-screen">
        <h1>REVO</h1>
        <div class="sub-text">CHOOSE YOUR LOADOUT</div>
        <div class="loadout-container" id="menu-grid"></div>
        <button id="deploy-btn" disabled>DEPLOY TO BATTLE</button>
    </div>

    <div id="ui-layer">
        <div id="versus-hud">
            <div id="p-score" class="vs-score">0</div>
            <div id="match-timer">2:30</div>
            <div id="e-score" class="vs-score">0</div>
        </div>
        
        <div id="round-announcement">ROUND START</div>

        <div id="flash-overlay"></div>
        <div id="crosshair">
            <div class="ch-bar ch-v ch-top"></div><div class="ch-bar ch-v ch-bottom"></div>
            <div class="ch-bar ch-h ch-left"></div><div class="ch-bar ch-h ch-right"></div>
        </div>
        <div class="ammo-display" id="ammo-text">30 / 30</div>
        <div class="health-bar"><div class="health-fill" id="hp-bar"></div></div>
        <div class="weapon-slots" id="hud-slots"></div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- NETWORK & MULTIPLAYER SETUP ---
        const urlParams = new URLSearchParams(window.location.search);
        const gameMode = urlParams.get('mode') || 'vsai';
        const netRole = urlParams.get('role');
        const netRoom = urlParams.get('room');
        const isMultiplayer = (gameMode === 'online');
        const isHost = (netRole === 'host');
        
        let peer;
        let peerConn;
        let networkPlayerObj = null;

        if (isMultiplayer) {
            document.getElementById('network-status').style.display = 'block';
            document.getElementById('loading-screen').style.display = 'flex';
            peer = new Peer(isHost ? netRoom : undefined);

            if (isHost) {
                document.getElementById('network-status').innerText = "WAITING FOR OPPONENT...";
                document.getElementById('loading-msg').innerText = "HOSTING ROOM: " + netRoom;
                peer.on('connection', (conn) => {
                    peerConn = conn;
                    setupNetwork();
                });
            } else {
                document.getElementById('network-status').innerText = "CONNECTING TO HOST...";
                document.getElementById('loading-msg').innerText = "CONNECTING TO ROOM: " + netRoom;
                peer.on('open', () => {
                    peerConn = peer.connect(netRoom, { reliable: true });
                    setupNetwork();
                });
                document.getElementById('map-header').innerText = "WAITING FOR HOST TO SELECT ARENA...";
                document.getElementById('map-cards-container').style.display = 'none';
            }
        }

        function setupNetwork() {
            peerConn.on('open', () => {
                document.getElementById('loading-screen').style.display = 'none';
                const statusEl = document.getElementById('network-status');
                statusEl.innerText = "NETWORK: SECURED";
                statusEl.style.color = "#00ffcc";
                statusEl.style.borderColor = "#00ffcc";
            });

            peerConn.on('data', (data) => {
                if (data.type === 'map_select') {
                    selectedMap = data.map;
                    document.getElementById('map-screen').style.display = 'none';
                    document.getElementById('selection-screen').style.display = 'flex';
                }
                if (data.type === 'state' && networkPlayerObj) {
                    networkPlayerObj.position.copy(data.pos);
                    networkPlayerObj.rotation.y = data.rotY;
                }
                if (data.type === 'shoot') {
                    spawnNetworkBullet(data.pos, data.dir, data.damage, data.perk);
                }
                if (data.type === 'hit') {
                    takePlayerDamage(data.damage);
                }
                if (data.type === 'death') {
                    pScore++;
                    document.getElementById('p-score').innerText = pScore;
                    if(!checkGameEnd()) resetRound();
                }
                if (data.type === 'throwable') {
                    const config = WEAPON_CONFIG[data.name];
                    const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), new THREE.MeshStandardMaterial({color: config.color}));
                    mesh.position.copy(data.pos);
                    mesh.userData = { vel: new THREE.Vector3(data.vel.x, data.vel.y, data.vel.z), type: "grenade", config: config, name: data.name, grounded: false };
                    scene.add(mesh); throwables.push(mesh);
                }
                if (data.type === 'tactical_self') {
                    if (data.name === "Stim-Shot" && networkPlayerObj) {
                        spawnParticles(networkPlayerObj.position, 50, 'spark', 0x00ff00);
                    }
                }
            });
        }

        // --- ROUND LIMIT SYSTEM ---
        const MAX_ROUNDS = 5;
        let isGameOver = false;

        function checkGameEnd() {
            let totalRoundsPlayed = pScore + eScore;
            if (totalRoundsPlayed >= MAX_ROUNDS) {
                isGameOver = true;
                const ann = document.getElementById('round-announcement');
                let resultText = pScore > eScore ? "MATCH VICTORY!" : (eScore > pScore ? "MATCH DEFEAT" : "DRAW");
                ann.innerHTML = `${resultText}<br><span style="font-size:1.5rem;color:#ccc;">REBOOTING SIMULATION...</span>`;
                ann.style.opacity = 1;
                
                document.getElementById('match-timer').innerText = "0:00";
                
                setTimeout(() => {
                    window.location.reload(); 
                }, 5000);
                return true;
            }
            return false;
        }

        // --- CONFIG & STATE ---
        const WEAPON_CONFIG = {
            "Volt-AR": { mag: 30, reload: 1500, rpm: 650, type: "auto", color: 0x333333, damage: 22, weight: 1.0 },
            "Marksman-7": { mag: 12, reload: 2000, rpm: 300, type: "semi", color: 0x4a3728, damage: 55, weight: 1.1 },
            "Cutter SMG": { mag: 40, reload: 1000, rpm: 950, type: "auto", color: 0x111111, damage: 14, weight: 1.2 },
            "Burst-Pulse": { mag: 24, reload: 1800, rpm: 400, type: "burst", color: 0x2c3e50, damage: 20, weight: 1.0 },
            "Slug-Shotty": { mag: 5, reload: 3000, rpm: 60, type: "semi", color: 0x1a1a1a, kick: 0.5, damage: 110, weight: 0.9 },
            "Carbine-X": { mag: 25, reload: 2000, rpm: 550, type: "auto", color: 0x273c75, damage: 26, weight: 1.0 },
            "LMG-Heavy": { mag: 100, reload: 4500, rpm: 500, type: "auto", color: 0x2f3640, damage: 28, weight: 0.6 },
            "Standard 9mm": { mag: 15, reload: 1200, rpm: 450, type: "semi", color: 0x353b48, damage: 18, weight: 1.3 },
            "Shorty": { mag: 2, reload: 2500, rpm: 100, type: "semi", color: 0x192a56, damage: 85, weight: 1.1 },
            "Magnum .44": { mag: 6, reload: 2500, rpm: 120, type: "semi", color: 0x7f8c8d, damage: 65, weight: 1.0 },
            "Auto-Pistol": { mag: 20, reload: 1200, rpm: 800, type: "auto", color: 0x2f3640, damage: 12, weight: 1.3 },
            "Silenced USP": { mag: 12, reload: 1500, rpm: 450, type: "semi", color: 0x1e272e, damage: 20, weight: 1.3 },
            "Laser-Pistol": { mag: Infinity, reload: 0, rpm: 600, type: "laser", color: 0x00d2d3, damage: 10, weight: 1.3 },
            "Hand Cannon": { mag: 1, reload: 3500, rpm: 30, type: "semi", color: 0x485460, damage: 250, weight: 0.9 },
            
            "Molotov": { type: "throwable", effect: "fire", cooldown: 2000, color: 0xff4400, aoeDmg: 5, radius: 15, weight: 1.3 },
            "Flare Gun": { type: "projectile", effect: "flare", cooldown: 1000, color: 0xff0000, aoeDmg: 2, radius: 20, weight: 1.3 },
            "Flashbang": { type: "throwable", effect: "flash", cooldown: 2000, color: 0xdddddd, weight: 1.3 },
            "Smoke Screen": { type: "throwable", effect: "smoke", cooldown: 3000, color: 0x555555, weight: 1.3 },
            "Shock Trap": { type: "throwable", effect: "shock", cooldown: 2000, color: 0x00ffff, aoeDmg: 10, radius: 12, weight: 1.3 },
            "Stim-Shot": { type: "self", effect: "heal", cooldown: 5000, color: 0x00ff00, weight: 1.3 },
            "Decoy Grenade": { type: "throwable", effect: "sound", cooldown: 2000, color: 0xffaa00, weight: 1.3 },

            "Tactical Knife": { rpm: 150, type: "melee", color: 0x222222, damage: 65, weight: 1.4 },
            "Karambit": { rpm: 100, type: "melee", color: 0x111111, damage: 85, weight: 1.4 },
            "Butterfly Knife": { rpm: 150, type: "melee", color: 0x333333, damage: 70, weight: 1.4 },
            "Stun Baton": { rpm: 600, type: "melee", color: 0x0984e3, damage: 35, weight: 1.3 },
            "Brass Knuckles": { rpm: 120, type: "melee", color: 0xd63031, damage: 50, weight: 1.4 },
            "Tomahawk": { rpm: 1000, type: "melee", color: 0x2d3436, damage: 95, weight: 1.3 },
            "Crowbar": { rpm: 700, type: "melee", color: 0xfa8231, damage: 60, weight: 1.2 }
        };

        const LOADOUT_DATA = [
            { name: "PRIMARY", items: ["Volt-AR", "Marksman-7", "Cutter SMG", "Burst-Pulse", "Slug-Shotty", "Carbine-X", "LMG-Heavy"] },
            { name: "SECONDARY", items: ["Standard 9mm", "Shorty", "Magnum .44", "Auto-Pistol", "Silenced USP", "Laser-Pistol", "Hand Cannon"] },
            { name: "TACTICAL", items: ["Molotov", "Flare Gun", "Flashbang", "Smoke Screen", "Shock Trap", "Stim-Shot", "Decoy Grenade"] },
            { name: "MELEE", items: ["Tactical Knife", "Karambit", "Butterfly Knife", "Stun Baton", "Brass Knuckles", "Tomahawk", "Crowbar"] },
            { name: "PERK", items: ["None", "Head-Hunter", "Rebound"] }
        ];

        let selectedItems = [null, null, null, null, null];
        let ammoState = [0, 0, 1, 0, 0]; 
        let isReloading = false;
        let isScoping = false; 
        let laserHeat = 0;
        let maxHealth = 300; 
        let health = maxHealth;

        // MATCH STATE & ADVANCED MECHANICS STATE
        let selectedMap = null;
        let roundTimeLength = 150; // 2:30 mins
        let matchTimeRemaining = roundTimeLength; 
        let pScore = 0;
        let eScore = 0;
        let mapColliders = []; 
        let aiController = null;
        let isProne = false;
        let isWallRunning = false;
        let isSprintingState = false;
        let jumpPads = [];

        let scene, camera, renderer, controls, weaponGroup;
        let isGrounded = true, velocity = new THREE.Vector3(), direction = new THREE.Vector3();
        let moveFwd = false, moveBwd = false, moveL = false, moveR = false, isSliding = false;
        let activeWeaponIndex = 0;
        let canShoot = true;
        let lastDashTime = 0; 
        let isShooting = false; 

        let targetSway = new THREE.Vector2(0,0);
        let currentSway = new THREE.Vector2(0,0);

        let bullets = [];
        let enemyBullets = []; 
        let particles = [];
        let throwables = [];
        let activeAOEs = [];
        let motionLines = [];
        let damageTexts = [];
        let dummy;

        const bulletRaycaster = new THREE.Raycaster();

        // Global Stun Function
        function stunEnemies(duration) {
            if (aiController) aiController.stun = duration;
        }

        // --- PROCEDURAL TEXTURES ---
        function generateProceduralTexture(type, color1, color2) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color1; ctx.fillRect(0,0,256,256);
            
            if (type === 'grid') {
                ctx.strokeStyle = color2; ctx.lineWidth = 4;
                ctx.strokeRect(0,0,256,256);
            } else if (type === 'stripes') {
                ctx.fillStyle = color2;
                for(let i=0; i<256; i+=32) ctx.fillRect(0, i, 256, 16);
            } else if (type === 'bricks') {
                ctx.strokeStyle = color2; ctx.lineWidth = 4;
                for(let y=0; y<256; y+=64) {
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(256, y); ctx.stroke();
                    let offset = (y % 128 === 0) ? 0 : 64;
                    for(let x=offset; x<256; x+=128) {
                        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y+64); ctx.stroke();
                    }
                }
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createParticleTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            if(type === 'soft') {
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(1, 'rgba(255,255,255,0)');
            } else if (type === 'spark') {
                ctx.fillStyle = 'white';
                ctx.fillRect(10,0,12,32); ctx.fillRect(0,10,32,12);
                return new THREE.CanvasTexture(canvas);
            }
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }
        
        const smokeTex = createParticleTexture('soft');
        const sparkTex = createParticleTexture('spark');

        // --- UI LOGIC ---
        document.querySelectorAll('.map-card').forEach(card => {
            card.onclick = () => {
                if(isMultiplayer && !isHost) return; 

                document.querySelectorAll('.map-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                
                let chosenMap = card.getAttribute('data-map');
                if (chosenMap === 'Random') {
                    const maps = ['Playground', 'SkyPort', 'Construction', 'Container'];
                    chosenMap = maps[Math.floor(Math.random() * maps.length)];
                }
                selectedMap = chosenMap;

                if (isMultiplayer && isHost && peerConn && peerConn.open) {
                    peerConn.send({ type: 'map_select', map: selectedMap });
                }

                setTimeout(() => {
                    document.getElementById('map-screen').style.display = 'none';
                    document.getElementById('selection-screen').style.display = 'flex';
                }, 300);
            };
        });

        const menuGrid = document.getElementById('menu-grid');
        function buildMenu() {
            menuGrid.innerHTML = "";
            LOADOUT_DATA.forEach((cat, catIdx) => {
                const col = document.createElement('div');
                col.className = 'category-column';
                col.innerHTML = `<div class="category-title">${cat.name}</div>`;
                const list = document.createElement('div'); list.className = 'item-list';
                cat.items.forEach((item) => {
                    const btn = document.createElement('div'); btn.className = 'item-btn'; btn.innerHTML = item; 
                    if(selectedItems[catIdx] === item) btn.classList.add('selected');
                    btn.onclick = () => {
                        col.querySelectorAll('.item-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        selectedItems[catIdx] = item;
                        checkDeploy();
                    };
                    list.appendChild(btn);
                });
                col.appendChild(list); menuGrid.appendChild(col);
            });
        }
        buildMenu();

        function checkDeploy() { document.getElementById('deploy-btn').disabled = selectedItems.includes(null); }

        document.getElementById('deploy-btn').onclick = () => {
            document.getElementById('selection-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';
            selectedItems.forEach((name, i) => {
                if (i < 4) { // Ignore perk slot for ammo configuration
                    const config = WEAPON_CONFIG[name];
                    ammoState[i] = config ? (i === 2 ? 1 : config.mag) : 1;
                }
            });
            initGame();
        };

        // --- SECRET CODE LOGIC ---
        let secretBuffer = "";
        window.addEventListener('keydown', (e) => {
            if(e.key && e.key.length === 1) secretBuffer += e.key;
            if(secretBuffer.length > 10) secretBuffer = secretBuffer.slice(-10);
            if(secretBuffer.includes("ragbo") && !WEAPON_CONFIG["OBS"]) {
                secretBuffer = "";
                WEAPON_CONFIG["OBS"] = { mag: Infinity, reload: 0, rpm: 30, type: "obs", color: 0x8b4513, damage: 1500, weight: 1.0 };
                alert("OBS (Orbital Strike Cannon) UNLOCKED! Added to Melee Weapons (Slot 4).");
                LOADOUT_DATA[3].items.push("OBS"); // Slot 4 is the Melee category (Index 3)
                buildMenu();
                
                // If in game, auto equip it into slot 4
                if(document.getElementById('ui-layer').style.display === 'block') {
                    selectedItems[3] = "OBS";
                    activeWeaponIndex = 3;
                    updateWeaponModel();
                    updateAmmoUI();
                    const slot = document.getElementById('hud-slot-3');
                    if(slot) { slot.innerText = "OBS"; slot.classList.add('active'); }
                }
            }
        });

        function resetRound() {
            if (isGameOver) return; 

            const ann = document.getElementById('round-announcement');
            ann.innerText = "ROUND RESET";
            ann.style.opacity = 1;
            setTimeout(() => { if(!isGameOver) ann.style.opacity = 0; }, 2000);

            activeAOEs.forEach(aoe => scene.remove(aoe.light)); activeAOEs = [];
            bullets.forEach(b => scene.remove(b)); bullets = [];
            enemyBullets.forEach(b => scene.remove(b)); enemyBullets = [];
            throwables.forEach(t => scene.remove(t)); throwables = [];
            particles.forEach(p => scene.remove(p.mesh)); particles = [];
            
            health = maxHealth;
            document.getElementById('hp-bar').style.width = '100%';
            isProne = false;
            
            let spawnP = selectedMap === "Construction" ? new THREE.Vector3(45, 15, 120) : new THREE.Vector3(0, 10, 40);
            let spawnE = selectedMap === "Construction" ? new THREE.Vector3(-45, 15, -120) : new THREE.Vector3(0, 10, -40);

            controls.getObject().position.copy(spawnP);
            velocity.set(0,0,0);
            
            if (aiController) {
                aiController.health = aiController.maxHealth;
                aiController.stun = 0;
                aiController.mesh.position.copy(spawnE); 
                aiController.pickNewTarget();
                aiController.randomizeLoadout();
            } else if (networkPlayerObj) {
                networkPlayerObj.position.copy(spawnE);
            }

            matchTimeRemaining = roundTimeLength;
            updateTimerUI();
        }

        function updateTimerUI() {
            if(isGameOver) return;
            let mins = Math.floor(matchTimeRemaining / 60);
            let secs = matchTimeRemaining % 60;
            document.getElementById('match-timer').innerText = `${mins}:${secs < 10 ? '0' : ''}${secs}`;
        }

        // --- MAP BUILDERS ---
        function buildMap(mapType) {
            const addObj = (geo, mat, pos, rot = [0,0,0]) => {
                mat.flatShading = true;
                mat.roughness = 0.8;
                mat.metalness = 0.1;
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(...pos); mesh.rotation.set(...rot);
                mesh.receiveShadow = true; mesh.castShadow = true;
                scene.add(mesh); mapColliders.push(mesh);
                return mesh;
            };

            const addJumpPad = (pos) => {
                const padMat = new THREE.MeshStandardMaterial({color: 0x00ffcc, emissive: 0x0088aa});
                const padGeo = new THREE.CylinderGeometry(4, 4, 0.5, 16);
                const pad = new THREE.Mesh(padGeo, padMat);
                pad.position.set(...pos); scene.add(pad); jumpPads.push(pad);
            };

            const groundGeo = new THREE.PlaneGeometry(300, 300);
            
            if (mapType === "Playground") {
                scene.background = new THREE.Color(0x87CEEB); 
                const gridTex = generateProceduralTexture('grid', '#228B22', '#1b6b1b'); gridTex.repeat.set(30, 30);
                addObj(groundGeo, new THREE.MeshStandardMaterial({map: gridTex}), [0,0,0], [-Math.PI/2,0,0]); 
                
                addObj(new THREE.BoxGeometry(30, 15, 30), new THREE.MeshStandardMaterial({color: 0xFFFF00}), [0, 7.5, 0]);
                [[12,12], [-12,-12], [12,-12], [-12,12]].forEach(p => {
                    addObj(new THREE.BoxGeometry(4, 4, 4), new THREE.MeshStandardMaterial({color: 0xFF8C00}), [p[0], 17, p[1]]);
                });
                
                const wedgeGeo = new THREE.ConeGeometry(10, 20, 4);
                addObj(wedgeGeo, new THREE.MeshStandardMaterial({color: 0x0000FF}), [-40, 5, 20], [0, Math.PI/4, Math.PI/2]);
                addObj(wedgeGeo, new THREE.MeshStandardMaterial({color: 0x0000FF}), [-40, 5, -20], [0, -Math.PI/4, Math.PI/2]);

                for(let i=-2; i<=2; i++) {
                    addObj(new THREE.CylinderGeometry(2, 2, 25, 16), new THREE.MeshStandardMaterial({color: 0xFF0000}), [40, 12.5, i * 15]);
                }

                addJumpPad([25, 0.25, 25]); 
                addJumpPad([-25, 0.25, -25]);
            } 
            else if (mapType === "SkyPort") {
                scene.background = new THREE.Color(0x0a0a1a); 
                
                const tileTex = generateProceduralTexture('grid', '#eeeeee', '#cccccc'); tileTex.repeat.set(16, 8);
                addObj(new THREE.BoxGeometry(160, 2, 80), new THREE.MeshStandardMaterial({map: tileTex}), [0, -1, 0]);
                
                addObj(new THREE.BoxGeometry(60, 1, 20), new THREE.MeshPhysicalMaterial({color: 0xddddff, transmission: 0.9, opacity: 1, transparent: true}), [0, 0.5, 0]);
                addObj(new THREE.BoxGeometry(10, 8, 2), new THREE.MeshStandardMaterial({color: 0x333333}), [5, 4, 2]);
                addObj(new THREE.BoxGeometry(2, 8, 10), new THREE.MeshStandardMaterial({color: 0x333333}), [9, 4, 6]);
                addObj(new THREE.BoxGeometry(10, 8, 2), new THREE.MeshStandardMaterial({color: 0x333333}), [-5, 4, -2]);
                addObj(new THREE.BoxGeometry(2, 8, 10), new THREE.MeshStandardMaterial({color: 0x333333}), [-9, 4, -6]);

                addObj(new THREE.CylinderGeometry(3, 3, 0.5, 16), new THREE.MeshStandardMaterial({color: 0x00ff00, emissive: 0x005500}), [-50, 0.5, 20]);
                addObj(new THREE.BoxGeometry(20, 1, 20), new THREE.MeshStandardMaterial({color: 0x555555}), [-50, 30, 0]);

                addObj(new THREE.BoxGeometry(80, 1, 5), new THREE.MeshStandardMaterial({color: 0x888888}), [0, -10, 45]);

                addJumpPad([0, 0.25, 30]);
                addJumpPad([-60, 0.25, -15]);
            }
            else if (mapType === "Construction") {
                scene.background = new THREE.Color(0x87CEEB); 
                
                const woodTex = generateProceduralTexture('stripes', '#8B4513', '#A0522D'); woodTex.repeat.set(10, 10);
                const metalTex = generateProceduralTexture('grid', '#555555', '#333333'); metalTex.repeat.set(5, 5);
                
                addObj(new THREE.BoxGeometry(90, 4, 60), new THREE.MeshStandardMaterial({map: woodTex}), [45, 8, 120]);
                addObj(new THREE.BoxGeometry(60, 4, 120), new THREE.MeshStandardMaterial({map: woodTex}), [120, 8, 30]);
                addObj(new THREE.BoxGeometry(90, 4, 60), new THREE.MeshStandardMaterial({map: woodTex}), [-45, 8, -120]);
                addObj(new THREE.BoxGeometry(60, 4, 120), new THREE.MeshStandardMaterial({map: woodTex}), [-120, 8, -30]);

                addObj(new THREE.BoxGeometry(60, 4, 60), new THREE.MeshStandardMaterial({map: metalTex}), [0, 8, 0]);

                addObj(new THREE.BoxGeometry(18, 2, 60), new THREE.MeshStandardMaterial({map: woodTex}), [0, 8, 60]);
                addObj(new THREE.BoxGeometry(18, 2, 60), new THREE.MeshStandardMaterial({map: woodTex}), [0, 8, -60]);
                
                addObj(new THREE.BoxGeometry(40, 4, 40), new THREE.MeshStandardMaterial({map: woodTex}), [120, 8, -120]);
                addObj(new THREE.BoxGeometry(40, 4, 40), new THREE.MeshStandardMaterial({map: woodTex}), [-120, 8, 120]);
                
                addObj(new THREE.BoxGeometry(30, 2, 30), new THREE.MeshStandardMaterial({map: metalTex}), [60, 8, -60]);
                addObj(new THREE.BoxGeometry(30, 2, 30), new THREE.MeshStandardMaterial({map: metalTex}), [-60, 8, 60]);

                addObj(new THREE.BoxGeometry(24, 240, 24), new THREE.MeshStandardMaterial({color: 0xdddd00}), [-120, 120, 0]); // Tower
                addObj(new THREE.BoxGeometry(220, 12, 12), new THREE.MeshStandardMaterial({color: 0xdddd00}), [-20, 234, 0]); // Arm
                addObj(new THREE.CylinderGeometry(0.5, 0.5, 150), new THREE.MeshStandardMaterial({color: 0x111111}), [0, 159, 0]); // Cable
                
                // Construct Crane Ladder
                const ladderMat = new THREE.MeshStandardMaterial({color: 0x222222});
                for(let i=0; i<240; i+=4) {
                    addObj(new THREE.BoxGeometry(4, 0.5, 0.5), ladderMat, [-120, i, 12.5]);
                }

                addObj(new THREE.BoxGeometry(30, 30, 30), new THREE.MeshStandardMaterial({color: 0xaa0000}), [0, 69, 0]);
                addObj(new THREE.BoxGeometry(20, 20, 20), new THREE.MeshStandardMaterial({color: 0x880000}), [0, 20, 0]); 

                const barrelMat = new THREE.MeshStandardMaterial({color: 0xff0000});
                const b1 = addObj(new THREE.CylinderGeometry(2.5, 2.5, 6, 16), barrelMat, [120, 13, 30]); b1.userData = {isBarrel: true};
                const b2 = addObj(new THREE.CylinderGeometry(2.5, 2.5, 6, 16), barrelMat, [-120, 13, -30]); b2.userData = {isBarrel: true};
                const b3 = addObj(new THREE.CylinderGeometry(2.5, 2.5, 6, 16), barrelMat, [0, 33, 0]); b3.userData = {isBarrel: true};
                const b4 = addObj(new THREE.CylinderGeometry(2.5, 2.5, 6, 16), barrelMat, [60, 11, -60]); b4.userData = {isBarrel: true};
                const b5 = addObj(new THREE.CylinderGeometry(2.5, 2.5, 6, 16), barrelMat, [-60, 11, 60]); b5.userData = {isBarrel: true};
                const b6 = addObj(new THREE.CylinderGeometry(2.5, 2.5, 6, 16), barrelMat, [0, 13, 0]); b6.userData = {isBarrel: true};

                addJumpPad([30, 10.25, 30]);
                addJumpPad([-30, 10.25, -30]);
                addJumpPad([0, 10.25, -45]);
            }
            else { 
                scene.background = new THREE.Color(0x222222);
                addObj(groundGeo, new THREE.MeshStandardMaterial({color: 0x444444}), [0,0,0], [-Math.PI/2,0,0]);

                const ribTex = generateProceduralTexture('stripes', '#8b0000', '#6b0000'); ribTex.repeat.set(1, 5);
                const cGeo = new THREE.BoxGeometry(12, 12, 30);
                const cMat = new THREE.MeshStandardMaterial({map: ribTex});
                addObj(cGeo, cMat, [-10, 6, 0]); addObj(cGeo, cMat, [-10, 18, 0]);
                addObj(cGeo, cMat, [10, 6, 0]);  addObj(cGeo, cMat, [10, 18, 0]);

                addObj(new THREE.BoxGeometry(20, 10, 20), new THREE.MeshStandardMaterial({color: 0xcccc00}), [-60, 5, -30]);
                addObj(new THREE.BoxGeometry(16, 10, 16), new THREE.MeshStandardMaterial({color: 0x444444}), [-60, 6, -30]); 

                addJumpPad([0, 0.25, 20]);
                addJumpPad([0, 0.25, -20]);
            }

            if (mapType !== "Construction") {
                const boundaryMat = new THREE.MeshStandardMaterial({color: 0x303040, roughness: 1.0, flatShading: true});
                addObj(new THREE.BoxGeometry(160, 100, 10), boundaryMat, [0, 50, -80]);
                addObj(new THREE.BoxGeometry(160, 100, 10), boundaryMat, [0, 50, 80]);
                addObj(new THREE.BoxGeometry(10, 100, 160), boundaryMat, [-80, 50, 0]);
                addObj(new THREE.BoxGeometry(10, 100, 160), boundaryMat, [80, 50, 0]);
            }

            const rampMat = new THREE.MeshStandardMaterial({color: 0xff007f, flatShading: true});
            addObj(new THREE.BoxGeometry(20, 2, 40), rampMat, [30, 5, 30], [Math.PI/6, 0, 0]);
            addObj(new THREE.BoxGeometry(20, 2, 40), rampMat, [-30, 5, -30], [-Math.PI/6, 0, 0]);
            
            scene.fog = new THREE.FogExp2(scene.background, 0.003);
        }

        // --- SMART AI CLASS ---
        class SmartAI {
            constructor(dummyMesh) {
                this.mesh = dummyMesh; this.health = 300; this.maxHealth = 300; this.state = "pursue"; 
                this.dashCooldown = 0; this.shootCooldown = 0; this.grenadeCooldown = 500;
                this.stun = 0;
                this.moveSpeed = 0.15; 
                this.targetPos = new THREE.Vector3(); this.pickNewTarget();
                
                this.randomizeLoadout();
                
                this.hpUI = document.createElement('div');
                this.hpUI.style.position = 'absolute'; this.hpUI.style.width = '50px'; this.hpUI.style.height = '5px';
                this.hpUI.style.background = 'red'; this.hpUI.style.border = '1px solid black';
                document.getElementById('ui-layer').appendChild(this.hpUI);
            }
            
            randomizeLoadout() {
                this.loadout = {
                    primary: LOADOUT_DATA[0].items[Math.floor(Math.random() * LOADOUT_DATA[0].items.length)],
                    secondary: LOADOUT_DATA[1].items[Math.floor(Math.random() * LOADOUT_DATA[1].items.length)],
                    tactical: LOADOUT_DATA[2].items[Math.floor(Math.random() * LOADOUT_DATA[2].items.length)],
                    melee: LOADOUT_DATA[3].items[Math.floor(Math.random() * LOADOUT_DATA[3].items.length)],
                    perk: LOADOUT_DATA[4].items[Math.floor(Math.random() * LOADOUT_DATA[4].items.length)]
                };
                this.activeWeaponName = this.loadout.primary;
            }

            pickNewTarget() { 
                let range = selectedMap === "Construction" ? 240 : 80;
                this.targetPos.set((Math.random()-0.5)*range, 2.5, (Math.random()-0.5)*range); 
            }

            takeDamage(amt) {
                this.health -= amt; spawnParticles(this.mesh.position, 10, 'spark', 0xff007f);
                this.dashCooldown = 0; 
                if(this.health <= 0) this.die();
            }

            die() {
                pScore++; document.getElementById('p-score').innerText = pScore;
                if(!checkGameEnd()) resetRound(); 
            }

            update(playerPos, cameraObj) {
                if (this.stun > 0) {
                    this.stun--;
                    if (this.stun % 5 === 0) spawnParticles(this.mesh.position.clone().add(new THREE.Vector3(0,2,0)), 10, 'spark', 0xffff00);
                    return; // Prevent actions and movement when stunned
                }

                if(this.dashCooldown > 0) this.dashCooldown--;
                if(this.shootCooldown > 0) this.shootCooldown--;
                if(this.grenadeCooldown > 0) this.grenadeCooldown--;

                if (this.mesh.position.y < -50) {
                    this.takeDamage(this.maxHealth + 100);
                }

                const distToPlayer = this.mesh.position.distanceTo(playerPos);
                
                if (distToPlayer < 10) this.activeWeaponName = this.loadout.melee;
                else if (distToPlayer < 40) this.activeWeaponName = this.loadout.secondary;
                else this.activeWeaponName = this.loadout.primary;

                const config = WEAPON_CONFIG[this.activeWeaponName];

                const screenPos = this.mesh.position.clone().add(new THREE.Vector3(0, 4, 0));
                screenPos.project(cameraObj);
                if (screenPos.z < 1) {
                    this.hpUI.style.display = 'block';
                    this.hpUI.style.left = `${(screenPos.x * .5 + .5) * window.innerWidth - 25}px`;
                    this.hpUI.style.top = `${(-screenPos.y * .5 + .5) * window.innerHeight}px`;
                    this.hpUI.style.width = `${(this.health/this.maxHealth) * 50}px`;
                } else { this.hpUI.style.display = 'none'; }

                const dirToPlayer = playerPos.clone().sub(this.mesh.position).normalize();
                bulletRaycaster.set(this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)), dirToPlayer);
                let hits = bulletRaycaster.intersectObjects(mapColliders);
                let hasLOS = true;
                if (hits.length > 0 && hits[0].distance < distToPlayer) hasLOS = false;

                let moveDir = new THREE.Vector3(0,0,0);

                if (distToPlayer < 300 && hasLOS) {
                    this.state = "attack";
                    this.mesh.lookAt(playerPos.x, this.mesh.position.y, playerPos.z);
                    
                    if (this.dashCooldown <= 0 && Math.random() < 0.02) {
                        const dashDir = new THREE.Vector3((Math.random()-0.5), 0, (Math.random()-0.5)).normalize().multiplyScalar(4); 
                        this.mesh.position.add(dashDir); this.dashCooldown = 150; 
                        spawnParticles(this.mesh.position, 20, 'smoke', 0xffffff);
                    }

                    if (this.shootCooldown <= 0 && distToPlayer > (config.type === "melee" ? 0 : 3)) { 
                        this.shootAtPlayer(playerPos, config);
                        let rpmCalc = config.rpm ? (60000 / config.rpm) : 500;
                        this.shootCooldown = Math.floor(rpmCalc / 16) + Math.floor(Math.random() * 10); 
                    }

                    if (this.grenadeCooldown <= 0 && distToPlayer > 15) {
                        this.useTactical(playerPos); this.grenadeCooldown = 500; 
                    }

                    moveDir = new THREE.Vector3(1, 0, 0).applyQuaternion(this.mesh.quaternion).multiplyScalar(Math.sin(performance.now()*0.005) * this.moveSpeed * 2);
                } else {
                    this.state = "pursue";
                    this.targetPos = playerPos.clone();
                    this.mesh.lookAt(this.targetPos.x, this.mesh.position.y, this.targetPos.z);
                    moveDir = this.targetPos.clone().sub(this.mesh.position).normalize().multiplyScalar(this.moveSpeed * 1.5);
                }

                const ahead = this.mesh.position.clone().add(moveDir.clone().normalize().multiplyScalar(4));
                bulletRaycaster.set(ahead.add(new THREE.Vector3(0,2,0)), new THREE.Vector3(0,-1,0));
                let dropHits = bulletRaycaster.intersectObjects(mapColliders);
                if (dropHits.length === 0 || dropHits[0].distance > 20) {
                    moveDir.set(0, 0, 0); 
                    this.mesh.position.add(this.mesh.position.clone().sub(this.targetPos).normalize().multiplyScalar(this.moveSpeed * 2)); 
                } else {
                    this.mesh.position.add(moveDir);
                }

                const aiOrigin = this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0));
                
                bulletRaycaster.set(aiOrigin, new THREE.Vector3(0, -1, 0));
                let gHits = bulletRaycaster.intersectObjects(mapColliders);
                let groundY = -1000; 
                if (gHits.length > 0 && gHits[0].distance < 20) groundY = gHits[0].point.y + 2.5;

                if (this.mesh.position.y > groundY) {
                    this.mesh.position.y -= 0.5; 
                } else if (this.mesh.position.y < groundY && groundY !== -1000) {
                    this.mesh.position.y = groundY; 
                }

                const dirs = [
                    new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0), 
                    new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1),
                    new THREE.Vector3(1,0,1).normalize(), new THREE.Vector3(-1,0,1).normalize()
                ];
                for(let d of dirs) {
                    bulletRaycaster.set(aiOrigin, d);
                    let wHits = bulletRaycaster.intersectObjects(mapColliders);
                    if(wHits.length > 0 && wHits[0].distance < 3.0) {
                        if(Math.abs(wHits[0].face.normal.y) < 0.5) { 
                            let overlap = 3.0 - wHits[0].distance;
                            this.mesh.position.x += wHits[0].face.normal.x * overlap;
                            this.mesh.position.z += wHits[0].face.normal.z * overlap;
                            
                            if(wHits[0].distance < 1.0 && this.mesh.position.y - groundY < 1) {
                                this.mesh.position.y += 0.5;
                            }
                        }
                    }
                }
            }

            shootAtPlayer(playerPos, config) {
                if (config.type === "melee") {
                    weaponGroup.children[0].rotation.x = -1.2; 
                    if (this.mesh.position.distanceTo(playerPos) < 6) {
                        takePlayerDamage(config.damage);
                    }
                    setTimeout(() => { if(weaponGroup.children[0]) weaponGroup.children[0].rotation.x = 0; }, 200);
                    return;
                }

                const bGeo = new THREE.BoxGeometry(0.1, 0.1, 1.2);
                const bMat = new THREE.MeshBasicMaterial({color: config.color || 0xff0000}); 
                const b = new THREE.Mesh(bGeo, bMat);
                const target = playerPos.clone().add(new THREE.Vector3((Math.random()-0.5)*1.5, (Math.random()-0.5)*1.5, (Math.random()-0.5)*1.5));
                const dir = target.sub(this.mesh.position.clone().add(new THREE.Vector3(0,2,0))).normalize();
                
                b.position.copy(this.mesh.position).add(new THREE.Vector3(0,2,0)).add(dir.multiplyScalar(2));
                b.lookAt(b.position.clone().add(dir));
                b.userData = { velocity: dir.multiplyScalar(4), damage: config.damage || 15, perk: this.loadout.perk, hasRebounded: false };
                scene.add(b); enemyBullets.push(b);
            }

            useTactical(playerPos) {
                const tactName = this.loadout.tactical;
                const config = WEAPON_CONFIG[tactName];
                
                if (config.type === "self") {
                    if (tactName === "Stim-Shot") {
                        this.health = this.maxHealth;
                        spawnParticles(this.mesh.position, 50, 'spark', 0x00ff00);
                    }
                    return;
                }

                const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const mat = new THREE.MeshStandardMaterial({color: config.color}); 
                const mesh = new THREE.Mesh(geo, mat);
                const dir = playerPos.clone().sub(this.mesh.position).normalize();
                mesh.position.copy(this.mesh.position).add(new THREE.Vector3(0,3,0));
                
                mesh.userData = { vel: dir.multiplyScalar(20).add(new THREE.Vector3(0, 8, 0)), type: "grenade", name: tactName, config: config, grounded: false };
                scene.add(mesh); throwables.push(mesh);
            }
        }

        function initGame() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0x404040, 0.7));
            const sun = new THREE.DirectionalLight(0xffffff, 1.2);
            sun.position.set(100, 100, 50); sun.castShadow = true; scene.add(sun);

            buildMap(selectedMap || "Playground");

            controls = new PointerLockControls(camera, document.body); controls.lock();

            let spawnP = selectedMap === "Construction" ? new THREE.Vector3(45, 15, 120) : new THREE.Vector3(0, 10, 40);
            let spawnE = selectedMap === "Construction" ? new THREE.Vector3(-45, 15, -120) : new THREE.Vector3(0, 10, -40);

            dummy = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CapsuleGeometry(1.2, 3, 4, 8), new THREE.MeshStandardMaterial({color: 0xff007f}));
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.7), new THREE.MeshStandardMaterial({color: 0x555555}));
            head.position.y = 2.5; dummy.add(body, head);
            dummy.position.copy(spawnE); scene.add(dummy);

            if (isMultiplayer) {
                networkPlayerObj = dummy;
                aiController = null;
            } else {
                aiController = new SmartAI(dummy);
            }

            const lineGroup = new THREE.Group();
            for(let i=0; i<20; i++) {
                const line = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, 2), new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0}));
                line.position.set((Math.random()-0.5)*15, (Math.random()-0.5)*10, -5); lineGroup.add(line); motionLines.push(line);
            }
            camera.add(lineGroup);

            const hudSlots = document.getElementById('hud-slots');
            selectedItems.forEach((item, i) => {
                if (i < 4) { 
                    const slot = document.createElement('div'); slot.className = `slot ${i === 0 ? 'active' : ''}`;
                    slot.id = `hud-slot-${i}`; slot.setAttribute('data-key', i + 1); slot.innerText = item; hudSlots.appendChild(slot);
                }
            });

            weaponGroup = new THREE.Group(); camera.add(weaponGroup); scene.add(controls.getObject());
            controls.getObject().position.copy(spawnP); 

            setInterval(() => {
                if(matchTimeRemaining > 0 && !isGameOver) {
                    matchTimeRemaining--; updateTimerUI();
                } else if(matchTimeRemaining === 0 && !isGameOver) {
                    resetRound();
                }
            }, 1000);

            setupInputs(); updateWeaponModel(); updateAmmoUI(); animate();
            
            setTimeout(() => { document.getElementById('round-announcement').style.opacity = 0; }, 2000);
            document.getElementById('round-announcement').style.opacity = 1;
        }

        class DamageNumber {
            constructor(pos, value) {
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 128; const ctx = canvas.getContext('2d');
                ctx.font = 'bold 60px Montserrat'; ctx.fillStyle = value > 50 ? '#ff0000' : '#ffffff';
                ctx.textAlign = 'center'; ctx.fillText(Math.floor(value), 64, 64);
                this.sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
                this.sprite.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5), 2, (Math.random()-0.5)));
                this.sprite.scale.set(2, 2, 2); this.life = 1.0; scene.add(this.sprite);
            }
            update() {
                this.life -= 0.02; this.sprite.position.y += 0.05; this.sprite.material.opacity = this.life;
                if(this.life <= 0) { scene.remove(this.sprite); return false; }
                return true;
            }
        }

        function setupInputs() {
            window.oncontextmenu = (e) => e.preventDefault(); 
            window.onkeydown = (e) => {
                if(e.code === 'KeyW') moveFwd = true; if(e.code === 'KeyS') moveBwd = true;
                if(e.code === 'KeyA') moveL = true; if(e.code === 'KeyD') moveR = true;
                
                if(e.code === 'KeyZ') isProne = !isProne;

                if(e.code === 'ShiftLeft') isSprintingState = true;

                if(e.code === 'KeyS' && isSprintingState && performance.now() - lastDashTime > 800) {
                    const backward = new THREE.Vector3(0,0,1).applyQuaternion(camera.quaternion);
                    backward.y = 0; backward.normalize();
                    velocity.add(backward.multiplyScalar(150));
                    lastDashTime = performance.now();
                }

                if(e.code === 'ControlLeft' && !isSliding) { 
                    isSliding = true; 
                    if(isGrounded && performance.now() - lastDashTime > 800) {
                        const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                        forward.y = 0; forward.normalize();
                        velocity.add(forward.multiplyScalar(150)); 
                        lastDashTime = performance.now();
                    }
                }
                
                if(e.code === 'Space' && isGrounded) {
                    velocity.y += isSliding ? 55 : 35; 
                    if(isSliding) {
                        const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                        forward.y = 0; forward.normalize();
                        velocity.add(forward.multiplyScalar(80)); 
                    }
                }

                if(e.code === 'KeyR') reload();
                if(['1','2','3','4'].includes(e.key)) { activeWeaponIndex = parseInt(e.key) - 1; isScoping = false; updateWeaponModel(); updateAmmoUI(); }
            };
            window.onkeyup = (e) => {
                if(e.code === 'KeyW') moveFwd = false; if(e.code === 'KeyS') moveBwd = false;
                if(e.code === 'KeyA') moveL = false; if(e.code === 'KeyD') moveR = false;
                if(e.code === 'ShiftLeft') isSprintingState = false;
                if(e.code === 'ControlLeft') isSliding = false;
            };
            window.onmousedown = (e) => { 
                if(!controls.isLocked) return;

                if(e.button === 0) {
                    isShooting = true;
                    shoot(); 
                }
                
                if(e.button === 2) {
                    if (selectedItems[activeWeaponIndex] === "OBS") {
                        // OBS Secondary Attack - Massive spawn where you look
                        stunEnemies(300); // Stun AI for 5 seconds
                        const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
                        
                        bulletRaycaster.set(camera.position, dir);
                        let hits = bulletRaycaster.intersectObjects(mapColliders);
                        let center = hits.length > 0 ? hits[0].point : camera.position.clone().add(dir.multiplyScalar(100));

                        for(let i=0; i<100; i++) { // Massive TNT Storm
                            let angle = (i / 100) * Math.PI * 2;
                            let radius = Math.random() * 40;
                            let offset = new THREE.Vector3(Math.cos(angle)*radius, 10 + Math.random()*30, Math.sin(angle)*radius);
                            spawnTNT(center.clone().add(offset), true);
                        }
                    } else if(activeWeaponIndex === 0 || activeWeaponIndex === 1) {
                        isScoping = true;
                    }
                }
            };
            window.onmouseup = (e) => { 
                if(e.button === 0) isShooting = false; 
                if(e.button === 2) isScoping = false; 
            };

            // WEAPON SWAY INPUT
            window.addEventListener('mousemove', (e) => {
                if(!controls.isLocked) return;
                targetSway.x -= e.movementX * 0.001;
                targetSway.y -= e.movementY * 0.001;
                targetSway.x = Math.max(-0.1, Math.min(0.1, targetSway.x));
                targetSway.y = Math.max(-0.1, Math.min(0.1, targetSway.y));
            });
        }

        function updateAmmoUI() {
            const config = WEAPON_CONFIG[selectedItems[activeWeaponIndex]];
            const ammoText = document.getElementById('ammo-text');
            if (!config) return;
            if (activeWeaponIndex === 2) {
                ammoText.innerText = canShoot ? "READY" : "COOLDOWN"; ammoText.style.color = canShoot ? "#00ff00" : "#ff0000";
            } else if (config.type === "laser") {
                ammoText.innerText = `HEAT: ${Math.floor(laserHeat)}%`; ammoText.style.color = laserHeat > 80 ? "#ff0000" : "#00d2d3";
            } else if (config.type === "obs") {
                ammoText.innerText = "OBS READY"; ammoText.style.color = "#ffaa00";
            } else if (config.type === "melee") { ammoText.innerText = "READY"; } else {
                ammoText.innerText = isReloading ? "RELOADING..." : `${ammoState[activeWeaponIndex]} / ${config.mag}`; ammoText.style.color = "white";
            }
        }

        function reload() {
            const config = WEAPON_CONFIG[selectedItems[activeWeaponIndex]];
            if (!config || activeWeaponIndex === 2 || config.type === "melee" || config.type === "obs" || isReloading || ammoState[activeWeaponIndex] === config.mag) return;
            isReloading = true; updateAmmoUI(); 
            setTimeout(() => { ammoState[activeWeaponIndex] = config.mag; isReloading = false; updateAmmoUI(); }, config.reload);
        }

        function updateWeaponModel() {
            while(weaponGroup.children.length > 0) weaponGroup.remove(weaponGroup.children[0]);
            document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
            const hudSlot = document.getElementById(`hud-slot-${activeWeaponIndex}`); if(hudSlot) hudSlot.classList.add('active');

            const itemName = selectedItems[activeWeaponIndex];
            const config = WEAPON_CONFIG[itemName] || { color: 0xffffff };
            const weaponInner = new THREE.Group();

            if (itemName === "OBS") {
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 3), new THREE.MeshStandardMaterial({color: 0x8b4513}));
                pole.rotation.x = Math.PI / 2;
                pole.position.set(0, 0, -1.5);
                const string = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 1.5), new THREE.MeshStandardMaterial({color: 0xffffff}));
                string.position.set(0, -0.75, -3);
                weaponInner.add(pole, string);
            } else {
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 1.4), new THREE.MeshStandardMaterial({color: config.color, flatShading: true}));
                const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.8), new THREE.MeshStandardMaterial({color: 0x111111, flatShading: true})); barrel.position.z = -0.8;
                const mag = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.25), new THREE.MeshStandardMaterial({color: 0x000000, flatShading: true})); mag.position.set(0, -0.3, -0.2);
                weaponInner.add(body, barrel, mag);
                
                if(config.type === "melee") { mag.visible = false; barrel.scale.set(0.5, 3, 0.1); barrel.position.set(0, 0, -0.8); }
                if(activeWeaponIndex === 2) { barrel.visible = false; body.scale.set(1, 1, 0.5); }
            }

            weaponInner.position.set(0.8, -0.7, -1.2); weaponGroup.add(weaponInner);
        }

        class Particle {
            constructor(pos, type, color) {
                this.pos = pos.clone(); this.type = type; this.life = 1.0;
                if (type === 'fire') { this.vel = new THREE.Vector3((Math.random()-0.5)*15, Math.random()*25, (Math.random()-0.5)*15); this.decay = 0.01 + Math.random()*0.02; this.size = 5 + Math.random()*3; } 
                else if (type === 'smoke') { this.vel = new THREE.Vector3((Math.random()-0.5)*10, Math.random()*15, (Math.random()-0.5)*10); this.decay = 0.005; this.size = 10 + Math.random()*15; } 
                else if (type === 'spark') { this.vel = new THREE.Vector3((Math.random()-0.5)*40, (Math.random()-0.5)*40, (Math.random()-0.5)*40); this.decay = 0.05; this.size = 1.0; } 
                else if (type === 'flash') { this.vel = new THREE.Vector3(0,0,0); this.decay = 0.1; this.size = 20; } 
                else if (type === 'flare_core') { this.vel = new THREE.Vector3((Math.random()-0.5)*2, Math.random()*15, (Math.random()-0.5)*2); this.decay = 0.02; this.size = 4; }

                this.mesh = new THREE.Sprite(new THREE.SpriteMaterial({ map: type === 'spark' ? sparkTex : smokeTex, color: color, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending }));
                this.mesh.position.copy(this.pos); this.mesh.scale.set(this.size, this.size, this.size); scene.add(this.mesh);
            }
            update() {
                this.life -= this.decay; this.pos.addVectors(this.pos, this.vel.clone().multiplyScalar(0.016)); this.mesh.position.copy(this.pos);
                if (this.type === 'fire' || this.type === 'flare_core') { this.mesh.scale.set(this.size * this.life, this.size * this.life, 1); this.mesh.material.opacity = this.life; } 
                else if (this.type === 'smoke') { this.mesh.scale.multiplyScalar(1.02); this.mesh.material.opacity = this.life * 0.5; } 
                else { this.mesh.material.opacity = this.life; }
            }
        }

        function spawnParticles(pos, count, type, color) { for(let i=0; i<count; i++) particles.push(new Particle(pos, type, color)); }

        async function shoot() {
            const name = selectedItems[activeWeaponIndex]; const config = WEAPON_CONFIG[name];
            if(!canShoot || isReloading || !config || isGameOver) return;

            if (activeWeaponIndex === 2) { useTactical(name, config); return; }

            const targetObj = isMultiplayer ? networkPlayerObj : dummy;

            if (config.type === "obs") {
                canShoot = false;
                stunEnemies(300); // Stun AI for 5 seconds
                const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
                
                bulletRaycaster.set(camera.position, dir);
                let hits = bulletRaycaster.intersectObjects(mapColliders);
                let center = hits.length > 0 ? hits[0].point : camera.position.clone().add(dir.multiplyScalar(100));

                for(let i=0; i<50; i++) { // Increased Payload
                    spawnTNT(center.clone().add(new THREE.Vector3((Math.random()-0.5)*30, Math.random()*20 + 10, (Math.random()-0.5)*30)), false);
                }
                if(weaponGroup.children[0]) weaponGroup.children[0].rotation.x = -0.5;
                setTimeout(() => { if(weaponGroup.children[0]) weaponGroup.children[0].rotation.x = 0; canShoot = true; }, 1000);
                return;
            }

            if (config.type === "melee") {
                canShoot = false; weaponGroup.children[0].rotation.x = -1.2;
                if (targetObj && controls.getObject().position.distanceTo(targetObj.position) < 8) {
                    damageTexts.push(new DamageNumber(targetObj.position.clone().add(new THREE.Vector3(0,2,0)), config.damage)); 
                    if (isMultiplayer) {
                        if (peerConn && peerConn.open) peerConn.send({ type: 'hit', damage: config.damage });
                    } else {
                        aiController.takeDamage(config.damage);
                    }
                }
                setTimeout(() => { weaponGroup.children[0].rotation.x = 0; canShoot = true; }, 1000 * (60 / config.rpm)); return;
            }

            if (config.type !== "laser") { if (ammoState[activeWeaponIndex] <= 0) { reload(); return; } ammoState[activeWeaponIndex]--; }
            if (config.type === "laser") { if (laserHeat >= 100) return; laserHeat += 15; }

            canShoot = false; const shots = config.type === "burst" ? 3 : 1;
            for(let i=0; i<shots; i++) {
                spawnBullet(config.damage); weaponGroup.position.z += 0.1;
                if(config.kick) velocity.z += config.kick * 10;
                if(shots > 1) await new Promise(r => setTimeout(r, 80));
            }
            updateAmmoUI(); setTimeout(() => { canShoot = true; weaponGroup.position.z = 0; updateAmmoUI(); }, 60000 / config.rpm);
        }

        function useTactical(name, config) {
            canShoot = false; updateAmmoUI();
            if(config.type === "self") { 
                if(name === "Stim-Shot") { 
                    health = maxHealth; document.getElementById('hp-bar').style.width = '100%'; 
                    spawnParticles(controls.getObject().position, 50, 'spark', 0x00ff00); 
                    if (isMultiplayer && peerConn && peerConn.open) {
                        peerConn.send({ type: 'tactical_self', name: name });
                    }
                } 
            } else { 
                spawnThrowable(name, config); 
            }
            setTimeout(() => { canShoot = true; updateAmmoUI(); }, config.cooldown);
        }

        function spawnThrowable(name, config) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), new THREE.MeshStandardMaterial({color: config.color}));
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir); mesh.position.copy(camera.position).add(dir);
            mesh.userData = { vel: dir.clone().multiplyScalar(25).add(new THREE.Vector3(0, 5, 0)), type: "grenade", config: config, name: name, grounded: false };
            scene.add(mesh); throwables.push(mesh);
            
            if (isMultiplayer && peerConn && peerConn.open) {
                peerConn.send({ type: 'throwable', name: name, pos: mesh.position, vel: mesh.userData.vel });
            }
        }

        function spawnTNT(pos, explodeOnImpact) {
            const tntMat = new THREE.MeshStandardMaterial({color: 0xff3333});
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), tntMat);
            mesh.position.copy(pos);
            mesh.userData = { 
                vel: new THREE.Vector3(0, -10, 0), 
                type: "tnt", 
                grounded: false,
                explodeOnImpact: explodeOnImpact,
                life: 60 
            };
            scene.add(mesh);
            throwables.push(mesh);
        }

        function detonateTNT(t) {
            const pos = t.position.clone();
            scene.remove(t);
            // HUGE VFX
            spawnParticles(pos, 300, 'fire', 0xffaa00);
            spawnParticles(pos, 200, 'smoke', 0x555555);
            spawnParticles(pos, 200, 'spark', 0xffffff);
            const light = new THREE.PointLight(0xffaa00, 100, 800); light.position.copy(pos); scene.add(light);
            
            // HUGE DAMAGE AND AOE RADIUS
            activeAOEs.push({ pos, type: 'fire', color: 0xffaa00, life: 20, light: light, damage: 1500, radius: 80 });

            // Trigger a strong camera shake
            currentSway.x += (Math.random() - 0.5) * 0.8;
            currentSway.y += (Math.random() - 0.5) * 0.8;
        }

        function detonate(obj) {
            const name = obj.userData.name; const config = obj.userData.config || {aoeDmg: 15, radius: 15}; const pos = obj.position.clone();
            if (name === "Molotov" || name === "Enemy-Fire") {
                const fireLight = new THREE.PointLight(0xff4400, 15, 200); fireLight.position.copy(pos); scene.add(fireLight);
                activeAOEs.push({ pos, type: 'fire', color: 0xff4400, life: 30 * 60, light: fireLight, damage: config.aoeDmg, radius: config.radius || 15 });
            } 
            else if (name === "Flare Gun") {
                const flareLight = new THREE.PointLight(0xff0000, 20, 250); flareLight.position.copy(pos); scene.add(flareLight);
                activeAOEs.push({ pos, type: 'flare_core', color: 0xff0000, life: 30 * 60, light: flareLight, damage: config.aoeDmg, radius: config.radius || 20 });
            }
            else if (name === "Flashbang") {
                spawnParticles(pos, 50, 'spark', 0xffffff);
                if (pos.distanceTo(controls.getObject().position) < 60) { 
                    const overlay = document.getElementById('flash-overlay'); overlay.style.opacity = 1; overlay.style.transition = 'opacity 0.05s';
                    setTimeout(() => { overlay.style.transition = 'opacity 3s'; overlay.style.opacity = 0; }, 100);
                }
            }
            else if (name === "Smoke Screen") { spawnParticles(pos, 400, 'smoke', 0xcccccc); }
            else if (name === "Shock Trap") {
                spawnParticles(pos, 200, 'spark', 0x00ffff);
                const light = new THREE.PointLight(0x00ffff, 5, 200); light.position.copy(pos); scene.add(light);
                activeAOEs.push({ pos, type: 'spark', color: 0x00ffff, life: 5 * 60, light: light, damage: config.aoeDmg, radius: config.radius || 12 });
            }
            else if (name === "Decoy Grenade") { spawnParticles(pos, 50, 'spark', 0xffaa00); }
            scene.remove(obj);
        }

        function detonateBarrel(barrel) {
            const pos = barrel.position.clone();
            scene.remove(barrel);
            const idx = mapColliders.indexOf(barrel);
            if(idx > -1) mapColliders.splice(idx, 1);
            
            spawnParticles(pos, 50, 'fire', 0xff4400);
            const fireLight = new THREE.PointLight(0xff4400, 15, 200); fireLight.position.copy(pos); scene.add(fireLight);
            activeAOEs.push({ pos, type: 'fire', color: 0xff4400, life: 11, light: fireLight, damage: 150, radius: 40 });
        }

        function spawnBullet(dmg) {
            const b = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 1.2), new THREE.MeshBasicMaterial({color: 0xffff00}));
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            b.position.copy(camera.position).add(dir.multiplyScalar(1)); b.lookAt(camera.position.clone().add(dir).add(dir));
            b.userData = { velocity: dir.clone().multiplyScalar(5), damage: dmg || 10, perk: selectedItems[4], hasRebounded: false }; 
            scene.add(b); bullets.push(b);

            if (isMultiplayer && peerConn && peerConn.open) {
                peerConn.send({
                    type: 'shoot',
                    pos: camera.position,
                    dir: dir,
                    damage: dmg,
                    perk: selectedItems[4]
                });
            }
        }

        function spawnNetworkBullet(pos, dirVec, dmg, perk) {
            const b = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 1.2), new THREE.MeshBasicMaterial({color: 0xff0000}));
            const p = new THREE.Vector3(pos.x, pos.y, pos.z);
            const d = new THREE.Vector3(dirVec.x, dirVec.y, dirVec.z);
            b.position.copy(p).add(d.multiplyScalar(1));
            b.lookAt(p.clone().add(d).add(d));
            b.userData = { velocity: d.clone().multiplyScalar(5), damage: dmg || 10, perk: perk, hasRebounded: false }; 
            scene.add(b); enemyBullets.push(b);
        }

        function takePlayerDamage(amt) {
            if (isGameOver) return;

            health -= amt; 
            document.getElementById('hp-bar').style.width = `${Math.max(0, (health/maxHealth)*100)}%`;
            if (health <= 0) { 
                eScore++; 
                document.getElementById('e-score').innerText = eScore; 
                
                if (isMultiplayer && peerConn && peerConn.open) {
                    peerConn.send({ type: 'death' });
                }
                
                if(!checkGameEnd()) resetRound(); 
            }
        }

        let frameCount = 0;
        function animate() {
            requestAnimationFrame(animate);
            if (isGameOver) return; 

            if (isShooting && canShoot && !isReloading) {
                const config = WEAPON_CONFIG[selectedItems[activeWeaponIndex]];
                if (config && (config.type === "auto" || config.type === "laser")) {
                    shoot();
                }
            }

            const time = performance.now(); const delta = 0.016;
            frameCount++;

            if (aiController) aiController.update(controls.getObject().position, camera);

            // UPDATE WEAPON SWAY
            targetSway.lerp(new THREE.Vector2(0,0), 0.05);
            currentSway.lerp(targetSway, 0.1);
            if (weaponGroup.children.length > 0) {
                weaponGroup.rotation.y = currentSway.x;
                weaponGroup.rotation.x = isReloading ? 0.5 : currentSway.y;
            }

            if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta; velocity.y -= 9.8 * 12.0 * delta; 
                direction.z = Number(moveFwd) - Number(moveBwd); direction.x = Number(moveR) - Number(moveL); direction.normalize();

                // WEIGHT SYSTEM & SPRINT LOGIC
                let baseSpeed = isProne ? 150 : ((isSliding && isGrounded) ? 900 : (isWallRunning ? 700 : (isSprintingState && moveFwd ? 800 : 500))); 
                let weightMult = WEAPON_CONFIG[selectedItems[activeWeaponIndex]]?.weight || 1.0;
                let speed = baseSpeed * weightMult;

                if (moveFwd || moveBwd) velocity.z -= direction.z * speed * delta;
                if (moveL || moveR) velocity.x -= direction.x * speed * delta;

                controls.moveRight(-velocity.x * delta); 
                controls.moveForward(-velocity.z * delta); 
                controls.getObject().position.y += (velocity.y * delta);

                if (controls.getObject().position.y < -50) {
                    takePlayerDamage(maxHealth + 100);
                    velocity.y = 0;
                    
                    let respawnPos = selectedMap === "Construction" ? new THREE.Vector3(45, 15, 120) : new THREE.Vector3(0, 10, 40);
                    controls.getObject().position.copy(respawnPos);
                }

                // CRANE LADDER LOGIC
                if (selectedMap === "Construction") {
                    let dx = controls.getObject().position.x - (-120);
                    let dz = controls.getObject().position.z - 12.5;
                    if (dx*dx + dz*dz < 20 && moveFwd) {
                        velocity.y = 40; 
                        isGrounded = true; 
                    }
                }

                // --- WALL RUNNING ---
                isWallRunning = false;
                if (!isGrounded && moveFwd && !isProne) {
                    const leftDir = new THREE.Vector3(-1,0,0).applyQuaternion(camera.quaternion);
                    const rightDir = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
                    bulletRaycaster.set(controls.getObject().position, leftDir);
                    let leftHit = bulletRaycaster.intersectObjects(mapColliders);
                    bulletRaycaster.set(controls.getObject().position, rightDir);
                    let rightHit = bulletRaycaster.intersectObjects(mapColliders);
                    
                    if ((leftHit.length > 0 && leftHit[0].distance < 2.0) || (rightHit.length > 0 && rightHit[0].distance < 2.0)) {
                        isWallRunning = true;
                        velocity.y = Math.max(-10, velocity.y);
                    }
                }

                // --- EDGE MANTLE ---
                if (!isGrounded && velocity.y <= 0 && moveFwd && !isProne && !isWallRunning) {
                    const fwdDir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                    fwdDir.y = 0; fwdDir.normalize();
                    
                    bulletRaycaster.set(controls.getObject().position, fwdDir);
                    let chestHit = bulletRaycaster.intersectObjects(mapColliders);
                    
                    let headPos = controls.getObject().position.clone().add(new THREE.Vector3(0, 2.5, 0));
                    bulletRaycaster.set(headPos, fwdDir);
                    let headHit = bulletRaycaster.intersectObjects(mapColliders);
                    
                    if (chestHit.length > 0 && chestHit[0].distance < 2.0 && (headHit.length === 0 || headHit[0].distance > 2.0)) {
                        velocity.y = 40; 
                        velocity.add(fwdDir.multiplyScalar(30)); 
                    }
                }

                // --- JUMP PADS ---
                jumpPads.forEach(pad => {
                    let dx = controls.getObject().position.x - pad.position.x;
                    let dz = controls.getObject().position.z - pad.position.z;
                    let dy = controls.getObject().position.y - pad.position.y;
                    if (dx*dx + dz*dz < 25 && dy > 0 && dy < 10 && velocity.y <= 0) {
                        velocity.y = 120; 
                        isGrounded = false;
                        spawnParticles(pad.position, 20, 'spark', 0x00ffcc);
                    }
                });

                const pOrigin = controls.getObject().position.clone();
                bulletRaycaster.set(new THREE.Vector3(pOrigin.x, pOrigin.y, pOrigin.z), new THREE.Vector3(0, -1, 0));
                let gHits = bulletRaycaster.intersectObjects(mapColliders);
                
                let floorY = -1000; 
                let playerHeight = isProne ? 1.5 : (isSliding ? 2.5 : 5); 
                
                if (gHits.length > 0 && gHits[0].distance < 15) {
                    floorY = gHits[0].point.y + playerHeight; 
                }

                if (controls.getObject().position.y <= floorY && floorY !== -1000) { 
                    velocity.y = Math.max(0, velocity.y); 
                    controls.getObject().position.y = floorY; 
                    isGrounded = true; 
                } else { 
                    isGrounded = false; 
                }

                const hOrigin = new THREE.Vector3(controls.getObject().position.x, controls.getObject().position.y - 2.5, controls.getObject().position.z);
                const hDirs = [
                    new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0), 
                    new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1),
                    new THREE.Vector3(1,0,1).normalize(), new THREE.Vector3(-1,0,1).normalize(),
                    new THREE.Vector3(1,0,-1).normalize(), new THREE.Vector3(-1,0,-1).normalize()
                ];
                
                for (let dir of hDirs) {
                    bulletRaycaster.set(hOrigin, dir);
                    let hits = bulletRaycaster.intersectObjects(mapColliders);
                    if (hits.length > 0 && hits[0].distance < 1.5) {
                        if (Math.abs(hits[0].face.normal.y) < 0.6) {
                            let overlap = 1.5 - hits[0].distance;
                            controls.getObject().position.x += hits[0].face.normal.x * overlap;
                            controls.getObject().position.z += hits[0].face.normal.z * overlap;

                            if (velocity.x * hits[0].face.normal.x < 0) velocity.x = 0;
                            if (velocity.z * hits[0].face.normal.z < 0) velocity.z = 0;
                        }
                    }
                }

                if (isMultiplayer && peerConn && peerConn.open && frameCount % 2 === 0) {
                    peerConn.send({ type: 'state', pos: controls.getObject().position, rotY: camera.rotation.y });
                }
            }

            const isSprintingFX = (isSliding || isSprintingState) && isGrounded && (moveFwd || moveL || moveR);
            motionLines.forEach((l) => {
                if(isSprintingFX || isWallRunning) { l.material.opacity = 0.5; l.scale.z = 2 + Math.random() * 5; l.position.z += 1; if(l.position.z > 0) l.position.z = -15; } 
                else { l.material.opacity = THREE.MathUtils.lerp(l.material.opacity, 0, 0.1); }
            });

            for(let i = damageTexts.length - 1; i >= 0; i--) { if(!damageTexts[i].update()) damageTexts.splice(i, 1); }

            for(let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                bulletRaycaster.set(b.position, b.userData.velocity.clone().normalize());
                let hits = bulletRaycaster.intersectObjects(mapColliders);
                if (hits.length > 0 && hits[0].distance < b.userData.velocity.length()) {
                    if (hits[0].object.userData.isBarrel) {
                        detonateBarrel(hits[0].object);
                    } else {
                        spawnParticles(hits[0].point, 5, 'spark', 0xaaaaaa);
                        
                        if (b.userData.perk === "Rebound" && !b.userData.hasRebounded && Math.random() < 0.55) {
                            b.userData.hasRebounded = true;
                            b.userData.velocity.reflect(hits[0].face.normal);
                            b.position.copy(hits[0].point).add(hits[0].face.normal.clone().multiplyScalar(0.1));
                            b.lookAt(b.position.clone().add(b.userData.velocity));
                            continue;
                        }
                    }
                    scene.remove(b); bullets.splice(i, 1); continue;
                }

                b.position.add(b.userData.velocity); b.scale.z = 3.5; 

                const targetObj = isMultiplayer ? networkPlayerObj : dummy;

                if(targetObj && b.position.distanceTo(targetObj.position) < 3.5) { 
                    
                    let isHeadshot = (b.position.y - targetObj.position.y) >= 1.8;
                    let finalDmg = b.userData.damage;
                    
                    if (b.userData.perk === "Head-Hunter") {
                        finalDmg = isHeadshot ? finalDmg * 2.0 : finalDmg * 0.5; 
                    } else {
                        finalDmg = isHeadshot ? finalDmg * 1.5 : finalDmg; 
                    }
                    
                    damageTexts.push(new DamageNumber(b.position, finalDmg));
                    spawnParticles(b.position, 5, 'spark', isHeadshot ? 0xff0000 : 0xff007f);
                    
                    if (isMultiplayer) {
                        if (peerConn && peerConn.open) {
                            peerConn.send({ type: 'hit', damage: finalDmg });
                        }
                    } else {
                        aiController.takeDamage(finalDmg);
                    }
                    
                    scene.remove(b); bullets.splice(i, 1); continue;
                }
                if(b.position.distanceTo(camera.position) > 1000) { scene.remove(b); bullets.splice(i, 1); }
            }

            for(let i = enemyBullets.length - 1; i >= 0; i--) {
                const b = enemyBullets[i];
                bulletRaycaster.set(b.position, b.userData.velocity.clone().normalize());
                let hits = bulletRaycaster.intersectObjects(mapColliders);
                if (hits.length > 0 && hits[0].distance < b.userData.velocity.length()) {
                    if (hits[0].object.userData.isBarrel) {
                        detonateBarrel(hits[0].object);
                    } else {
                        spawnParticles(hits[0].point, 5, 'spark', 0xaaaaaa);

                        if (b.userData.perk === "Rebound" && !b.userData.hasRebounded && Math.random() < 0.55) {
                            b.userData.hasRebounded = true;
                            b.userData.velocity.reflect(hits[0].face.normal);
                            b.position.copy(hits[0].point).add(hits[0].face.normal.clone().multiplyScalar(0.1));
                            b.lookAt(b.position.clone().add(b.userData.velocity));
                            continue;
                        }
                    }
                    scene.remove(b); enemyBullets.splice(i, 1); continue;
                }

                b.position.add(b.userData.velocity); b.scale.z = 3.5; 

                if(b.position.distanceTo(controls.getObject().position) < 3.0) { 
                    
                    let headshotThreshold = controls.getObject().position.y - 1.5;
                    let isHeadshotPlayer = b.position.y > headshotThreshold;
                    let finalDmg = b.userData.damage;
                    
                    if (b.userData.perk === "Head-Hunter") {
                        finalDmg = isHeadshotPlayer ? finalDmg * 2.0 : finalDmg * 0.5;
                    } else {
                        finalDmg = isHeadshotPlayer ? finalDmg * 1.5 : finalDmg;
                    }
                    
                    takePlayerDamage(finalDmg);
                    scene.remove(b); enemyBullets.splice(i, 1); continue;
                }
                
                const remoteObj = isMultiplayer ? networkPlayerObj : dummy;
                if(remoteObj && b.position.distanceTo(remoteObj.position) > 1000) { scene.remove(b); enemyBullets.splice(i, 1); }
            }

            for(let i = activeAOEs.length - 1; i >= 0; i--) {
                const aoe = activeAOEs[i];
                
                if(Math.random() > 0.3) {
                    let spread = aoe.radius ? aoe.radius * 0.8 : 2;
                    spawnParticles(aoe.pos.clone().add(new THREE.Vector3((Math.random()-0.5)*spread, Math.random()*2, (Math.random()-0.5)*spread)), 2, aoe.type, aoe.color);
                }
                
                if (aoe.damage) {
                    let radius = aoe.radius || 15;
                    const targetObj = isMultiplayer ? networkPlayerObj : dummy;
                    
                    if (targetObj && aoe.pos.distanceTo(targetObj.position) < radius && aoe.life % 10 === 0) { 
                        damageTexts.push(new DamageNumber(targetObj.position.clone().add(new THREE.Vector3(0,2,0)), aoe.damage)); 
                        
                        if (isMultiplayer) {
                            if (peerConn && peerConn.open) peerConn.send({ type: 'hit', damage: aoe.damage });
                        } else {
                            aiController.takeDamage(aoe.damage);
                        }
                    }
                    
                    if (aoe.pos.distanceTo(controls.getObject().position) < radius && aoe.life % 10 === 0) {
                        takePlayerDamage(aoe.damage); 
                    }
                }

                aoe.life--; if(aoe.life <= 0) { scene.remove(aoe.light); activeAOEs.splice(i, 1); }
            }

            for(let i = throwables.length - 1; i >= 0; i--) {
                const t = throwables[i]; 
                
                if (t.userData.type === "tnt") {
                    if(t.userData.explodeOnImpact && t.userData.grounded) {
                        detonateTNT(t);
                        throwables.splice(i, 1);
                        continue;
                    }
                    if(!t.userData.explodeOnImpact) {
                        t.userData.life--;
                        if(t.userData.life <= 0) {
                            detonateTNT(t);
                            throwables.splice(i, 1);
                            continue;
                        }
                    }
                }

                t.userData.vel.y -= 0.5; t.position.add(t.userData.vel.clone().multiplyScalar(0.016));
                const speed = t.userData.vel.length(); 
                if (t.userData.type !== "tnt") {
                    t.scale.set(1, 1, 1 + (speed * 0.05)); 
                    t.lookAt(t.position.clone().add(t.userData.vel));
                }
                
                const stepDist = speed * 0.016;
                
                bulletRaycaster.set(t.position, t.userData.vel.clone().normalize());
                let hits = bulletRaycaster.intersectObjects(mapColliders);
                
                if (hits.length > 0 && hits[0].distance <= stepDist + 0.5) {
                    if (!t.userData.grounded) {
                        t.userData.grounded = true;
                        t.position.copy(hits[0].point); 
                        if (t.userData.type !== "tnt") {
                            setTimeout(() => { if(throwables.includes(t)) { detonate(t); const idx = throwables.indexOf(t); if(idx > -1) throwables.splice(idx, 1); } }, 100);
                        }
                    }
                } else {
                    bulletRaycaster.set(t.position, new THREE.Vector3(0, -1, 0));
                    let floorHits = bulletRaycaster.intersectObjects(mapColliders);
                    if (floorHits.length > 0 && floorHits[0].distance < 0.5 && !t.userData.grounded) {
                        t.userData.grounded = true;
                        t.position.y = floorHits[0].point.y + (t.userData.type === "tnt" ? 0.75 : 0.3);
                        if (t.userData.type !== "tnt") {
                            setTimeout(() => { if(throwables.includes(t)) { detonate(t); const idx = throwables.indexOf(t); if(idx > -1) throwables.splice(idx, 1); } }, 100);
                        }
                    }
                }
            }

            for(let i = particles.length - 1; i >= 0; i--) { particles[i].update(); if(particles[i].life <= 0) { scene.remove(particles[i].mesh); particles.splice(i, 1); } }

            let baseFov = (isSliding && isGrounded) ? 100 : (isSprintingState ? 90 : 75); 
            const targetFov = isScoping ? 40 : baseFov;
            camera.fov = THREE.MathUtils.lerp(camera.fov, targetFov, 0.2); camera.updateProjectionMatrix();
            if (weaponGroup.children[0]) {
                const targetWeaponPos = isScoping ? new THREE.Vector3(0, -0.45, -0.8) : new THREE.Vector3(0.8, -0.7, -1.2);
                weaponGroup.children[0].position.lerp(targetWeaponPos, 0.2);
            }
            weaponGroup.position.y = Math.sin(time * 0.005) * 0.01; weaponGroup.position.x = Math.cos(time * 0.003) * 0.01;
            renderer.render(scene, camera);
        }

        window.onresize = () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
    </script>
</body>
</html>
