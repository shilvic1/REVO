<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REVO - Advanced Combat</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@1,900&display=swap');
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Montserrat', sans-serif; user-select: none; }
        canvas { display: block; }

        #map-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
            z-index: 210; display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white;
        }
        .map-cards { display: flex; gap: 20px; margin-top: 30px; flex-wrap: wrap; justify-content: center;}
        .map-card {
            background: #222; border: 2px solid #444; padding: 20px; border-radius: 10px; cursor: pointer;
            width: 200px; text-align: center; transition: 0.2s;
        }
        .map-card:hover { border-color: #ff007f; transform: scale(1.05); }
        .map-card.selected { border-color: #00ffcc; box-shadow: 0 0 20px rgba(0, 255, 204, 0.4); }

        #selection-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%);
            z-index: 200; display: none; flex-direction: column; align-items: center; justify-content: flex-start;
            color: white; padding-top: 40px;
        }

        h1 { font-style: italic; font-size: 3rem; margin: 0; text-shadow: 0 0 10px #ff007f; text-transform: uppercase; }
        .sub-text { margin-bottom: 30px; color: #888; letter-spacing: 2px; font-size: 0.8rem; }

        .loadout-container {
            display: flex; gap: 20px; padding: 20px; background: rgba(255,255,255,0.05);
            border-radius: 15px; backdrop-filter: blur(10px); border: 1px solid #333;
            max-width: 90%; overflow-x: auto;
        }

        .category-column { display: flex; flex-direction: column; align-items: center; min-width: 200px; }
        .category-title { background: #ff007f; color: white; padding: 5px 15px; transform: skewX(-15deg); font-size: 0.9rem; margin-bottom: 15px; box-shadow: 0 0 10px rgba(255, 0, 127, 0.5); }

        .item-list { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; max-height: 400px; overflow-y: auto; padding: 5px; width: 100%; }

        .item-btn {
            background: linear-gradient(135deg, #222, #111); border: 2px solid #333; color: #aaa; aspect-ratio: 1/1;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.2s; border-radius: 8px; font-size: 0.65rem; text-align: center; padding: 5px; position: relative; overflow: hidden;
        }
        .item-btn::before { content: ''; width: 40px; height: 40px; background: rgba(255,255,255,0.1); border-radius: 50%; margin-bottom: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        .item-btn:hover { background: #333; border-color: #666; transform: translateY(-2px); }
        .item-btn.selected { border-color: #ff007f; background: linear-gradient(135deg, rgba(255, 0, 127, 0.2), #111); color: white; box-shadow: 0 0 15px rgba(255,0,127,0.3); }

        #deploy-btn {
            margin-top: 30px; padding: 15px 80px; font-size: 1.5rem; background: #ff007f; color: white;
            border: none; cursor: pointer; transform: skewX(-15deg); font-weight: 900; box-shadow: 0 0 30px rgba(255,0,127,0.4); transition: 0.3s;
        }
        #deploy-btn:hover { transform: skewX(-15deg) scale(1.05); background: #ff3399; }
        #deploy-btn:disabled { background: #333; cursor: not-allowed; box-shadow: none; opacity: 0.5; }

        /* --- GAME UI --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: none; }
        
        #versus-hud {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; align-items: center;
            background: rgba(0,0,0,0.8); border: 2px solid #333; border-radius: 10px; padding: 10px 20px;
        }
        .vs-score { font-size: 2rem; font-weight: 900; width: 50px; text-align: center; }
        #p-score { color: #00ffcc; text-shadow: 0 0 10px #00ffcc; }
        #e-score { color: #ff007f; text-shadow: 0 0 10px #ff007f; }
        #match-timer { font-size: 1.5rem; color: white; background: #222; padding: 5px 15px; border-radius: 5px; }
        
        #round-announcement {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
            font-size: 4rem; color: white; font-style: italic; font-weight: 900;
            text-shadow: 0 0 20px #ff007f; opacity: 0; transition: opacity 0.5s; z-index: 100;
        }

        #flash-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; transition: opacity 0.1s; pointer-events: none; z-index: 999; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 24px; height: 24px; }
        .ch-bar { position: absolute; background: #ff0000; border: 1px solid #000; border-radius: 1px;}
        .ch-v { width: 4px; height: 10px; } .ch-h { width: 10px; height: 4px; }
        .ch-top { top: 0; left: 10px; } .ch-bottom { bottom: 0; left: 10px; } .ch-left { left: 0; top: 10px; } .ch-right { right: 0; top: 10px; }
        
        .ammo-display { position: absolute; bottom: 80px; left: 45px; color: white; font-size: 24px; text-shadow: 2px 2px black; font-style: italic; }
        .health-bar { position: absolute; bottom: 40px; left: 40px; width: 350px; height: 22px; background: rgba(0,0,0,0.6); border: 3px solid #000; transform: skewX(-15deg); overflow: hidden; border-radius: 2px; }
        .health-fill { width: 100%; height: 100%; background: #4efc03; box-shadow: inset 0 0 10px rgba(0,0,0,0.5); transition: width 0.2s; }
        .weapon-slots { position: absolute; bottom: 40px; right: 40px; display: flex; gap: 12px; }
        .slot { width: 70px; height: 70px; background: rgba(10,10,10,0.9); border: 2px solid #222; border-radius: 4px; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; color: white; font-size: 0.7rem; text-align: center; padding: 5px; box-sizing: border-box;}
        .slot.active { border-color: #ff007f; background: rgba(255,0,127,0.15); transform: scale(1.1); box-shadow: 0 0 15px rgba(255,0,127,0.3); }
        .slot::after { content: attr(data-key); position: absolute; top: 2px; left: 6px; color: #ff007f; font-size: 11px; font-weight: 900; }
    </style>
</head>
<body>

    <div id="map-screen">
        <h1>SELECT ARENA</h1>
        <div class="map-cards" id="map-cards-container">
            <div class="map-card" data-map="Playground"><h3>The Playground</h3><p>High-Contrast Plastic</p></div>
            <div class="map-card" data-map="SkyPort"><h3>Sky Port</h3><p>Clean White/Minimalist</p></div>
            <div class="map-card" data-map="Temple"><h3>Temple of Blocks</h3><p>Zen/Sand/Smooth Stone</p></div>
            <div class="map-card" data-map="Container"><h3>Container Yard</h3><p>Classic Roblox FPS</p></div>
        </div>
    </div>

    <div id="selection-screen">
        <h1>REVO</h1>
        <div class="sub-text">CHOOSE YOUR LOADOUT</div>
        <div class="loadout-container" id="menu-grid"></div>
        <button id="deploy-btn" disabled>DEPLOY TO BATTLE</button>
    </div>

    <div id="ui-layer">
        <div id="versus-hud">
            <div id="p-score" class="vs-score">0</div>
            <div id="match-timer">2:30</div>
            <div id="e-score" class="vs-score">0</div>
        </div>
        
        <div id="round-announcement">ROUND START</div>

        <div id="flash-overlay"></div>
        <div id="crosshair">
            <div class="ch-bar ch-v ch-top"></div><div class="ch-bar ch-v ch-bottom"></div>
            <div class="ch-bar ch-h ch-left"></div><div class="ch-bar ch-h ch-right"></div>
        </div>
        <div class="ammo-display" id="ammo-text">30 / 30</div>
        <div class="health-bar"><div class="health-fill" id="hp-bar"></div></div>
        <div class="weapon-slots" id="hud-slots"></div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CONFIG & STATE ---
        const WEAPON_CONFIG = {
            "Volt-AR": { mag: 30, reload: 1500, rpm: 650, type: "auto", color: 0x333333, damage: 22 },
            "Marksman-7": { mag: 12, reload: 2000, rpm: 300, type: "semi", color: 0x4a3728, damage: 55 },
            "Cutter SMG": { mag: 40, reload: 1000, rpm: 950, type: "auto", color: 0x111111, damage: 14 },
            "Burst-Pulse": { mag: 24, reload: 1800, rpm: 400, type: "burst", color: 0x2c3e50, damage: 20 },
            "Slug-Shotty": { mag: 5, reload: 3000, rpm: 60, type: "semi", color: 0x1a1a1a, kick: 0.5, damage: 110 },
            "Carbine-X": { mag: 25, reload: 2000, rpm: 550, type: "auto", color: 0x273c75, damage: 26 },
            "LMG-Heavy": { mag: 100, reload: 4500, rpm: 500, type: "auto", color: 0x2f3640, damage: 28 },
            "Standard 9mm": { mag: 15, reload: 1200, rpm: 450, type: "semi", color: 0x353b48, damage: 18 },
            "Shorty": { mag: 2, reload: 2500, rpm: 100, type: "semi", color: 0x192a56, damage: 85 },
            "Magnum .44": { mag: 6, reload: 2500, rpm: 120, type: "semi", color: 0x7f8c8d, damage: 65 },
            "Auto-Pistol": { mag: 20, reload: 1200, rpm: 800, type: "auto", color: 0x2f3640, damage: 12 },
            "Silenced USP": { mag: 12, reload: 1500, rpm: 450, type: "semi", color: 0x1e272e, damage: 20 },
            "Laser-Pistol": { mag: Infinity, reload: 0, rpm: 600, type: "laser", color: 0x00d2d3, damage: 10 },
            "Hand Cannon": { mag: 1, reload: 3500, rpm: 30, type: "semi", color: 0x485460, damage: 250 },
            
            "Molotov": { type: "throwable", effect: "fire", cooldown: 2000, color: 0xff4400, aoeDmg: 5 },
            "Flare Gun": { type: "projectile", effect: "flare", cooldown: 1000, color: 0xff0000, aoeDmg: 2 },
            "Flashbang": { type: "throwable", effect: "flash", cooldown: 2000, color: 0xdddddd },
            "Smoke Screen": { type: "throwable", effect: "smoke", cooldown: 3000, color: 0x555555 },
            "Shock Trap": { type: "throwable", effect: "shock", cooldown: 2000, color: 0x00ffff, aoeDmg: 10 },
            "Stim-Shot": { type: "self", effect: "heal", cooldown: 5000, color: 0x00ff00 },
            "Decoy Grenade": { type: "throwable", effect: "sound", cooldown: 2000, color: 0xffaa00 },

            "Tactical Knife": { rpm: 150, type: "melee", color: 0x222222, damage: 65 },
            "Karambit": { rpm: 100, type: "melee", color: 0x111111, damage: 85 },
            "Butterfly Knife": { rpm: 150, type: "melee", color: 0x333333, damage: 70 },
            "Stun Baton": { rpm: 600, type: "melee", color: 0x0984e3, damage: 35 },
            "Brass Knuckles": { rpm: 120, type: "melee", color: 0xd63031, damage: 50 },
            "Tomahawk": { rpm: 1000, type: "melee", color: 0x2d3436, damage: 95 },
            "Crowbar": { rpm: 700, type: "melee", color: 0xfa8231, damage: 60 }
        };

        const LOADOUT_DATA = [
            { name: "PRIMARY", items: ["Volt-AR", "Marksman-7", "Cutter SMG", "Burst-Pulse", "Slug-Shotty", "Carbine-X", "LMG-Heavy"] },
            { name: "SECONDARY", items: ["Standard 9mm", "Shorty", "Magnum .44", "Auto-Pistol", "Silenced USP", "Laser-Pistol", "Hand Cannon"] },
            { name: "TACTICAL", items: ["Molotov", "Flare Gun", "Flashbang", "Smoke Screen", "Shock Trap", "Stim-Shot", "Decoy Grenade"] },
            { name: "MELEE", items: ["Tactical Knife", "Karambit", "Butterfly Knife", "Stun Baton", "Brass Knuckles", "Tomahawk", "Crowbar"] }
        ];

        let selectedItems = [null, null, null, null];
        let ammoState = [0, 0, 1, 0]; 
        let isReloading = false;
        let isScoping = false; 
        let laserHeat = 0;
        let health = 100;

        // MATCH STATE
        let selectedMap = null;
        let roundTimeLength = 150; // 2:30 mins
        let matchTimeRemaining = roundTimeLength; 
        let pScore = 0;
        let eScore = 0;
        let mapColliders = []; 
        let aiController = null;

        let scene, camera, renderer, controls, weaponGroup;
        let isGrounded = true, velocity = new THREE.Vector3(), direction = new THREE.Vector3();
        let moveFwd = false, moveBwd = false, moveL = false, moveR = false, isSliding = false;
        let activeWeaponIndex = 0;
        let canShoot = true;
        let lastDashTime = 0; // DASH COOLDOWN TRACKER
        
        let bullets = [];
        let enemyBullets = []; 
        let particles = [];
        let throwables = [];
        let activeAOEs = [];
        let motionLines = [];
        let damageTexts = [];
        let dummy;

        // REUSABLE RAYCASTER FOR COLLISION & COMBAT
        const bulletRaycaster = new THREE.Raycaster();

        // --- PROCEDURAL TEXTURES FOR EXTRA DETAIL ---
        function generateProceduralTexture(type, color1, color2) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color1; ctx.fillRect(0,0,256,256);
            
            if (type === 'grid') {
                ctx.strokeStyle = color2; ctx.lineWidth = 4;
                ctx.strokeRect(0,0,256,256);
            } else if (type === 'stripes') {
                ctx.fillStyle = color2;
                for(let i=0; i<256; i+=32) ctx.fillRect(0, i, 256, 16);
            } else if (type === 'bricks') {
                ctx.strokeStyle = color2; ctx.lineWidth = 4;
                for(let y=0; y<256; y+=64) {
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(256, y); ctx.stroke();
                    let offset = (y % 128 === 0) ? 0 : 64;
                    for(let x=offset; x<256; x+=128) {
                        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y+64); ctx.stroke();
                    }
                }
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createParticleTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            if(type === 'soft') {
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(1, 'rgba(255,255,255,0)');
            } else if (type === 'spark') {
                ctx.fillStyle = 'white';
                ctx.fillRect(10,0,12,32); ctx.fillRect(0,10,32,12);
                return new THREE.CanvasTexture(canvas);
            }
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }
        
        const smokeTex = createParticleTexture('soft');
        const sparkTex = createParticleTexture('spark');

        // --- UI LOGIC ---
        document.querySelectorAll('.map-card').forEach(card => {
            card.onclick = () => {
                document.querySelectorAll('.map-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                selectedMap = card.getAttribute('data-map');
                setTimeout(() => {
                    document.getElementById('map-screen').style.display = 'none';
                    document.getElementById('selection-screen').style.display = 'flex';
                }, 300);
            };
        });

        const menuGrid = document.getElementById('menu-grid');
        LOADOUT_DATA.forEach((cat, catIdx) => {
            const col = document.createElement('div');
            col.className = 'category-column';
            col.innerHTML = `<div class="category-title">${cat.name}</div>`;
            const list = document.createElement('div'); list.className = 'item-list';
            cat.items.forEach((item) => {
                const btn = document.createElement('div'); btn.className = 'item-btn'; btn.innerHTML = item; 
                btn.onclick = () => {
                    col.querySelectorAll('.item-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectedItems[catIdx] = item;
                    checkDeploy();
                };
                list.appendChild(btn);
            });
            col.appendChild(list); menuGrid.appendChild(col);
        });

        function checkDeploy() { document.getElementById('deploy-btn').disabled = selectedItems.includes(null); }

        document.getElementById('deploy-btn').onclick = () => {
            document.getElementById('selection-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';
            selectedItems.forEach((name, i) => {
                const config = WEAPON_CONFIG[name];
                ammoState[i] = config ? (i === 2 ? 1 : config.mag) : 1;
            });
            initGame();
        };

        // --- ROUND SYSTEM ---
        function resetRound() {
            const ann = document.getElementById('round-announcement');
            ann.innerText = "ROUND RESET";
            ann.style.opacity = 1;
            setTimeout(() => { ann.style.opacity = 0; }, 2000);

            activeAOEs.forEach(aoe => scene.remove(aoe.light)); activeAOEs = [];
            bullets.forEach(b => scene.remove(b)); bullets = [];
            enemyBullets.forEach(b => scene.remove(b)); enemyBullets = [];
            throwables.forEach(t => scene.remove(t)); throwables = [];
            particles.forEach(p => scene.remove(p.mesh)); particles = [];
            
            health = 100;
            document.getElementById('hp-bar').style.width = '100%';
            controls.getObject().position.set(0, 20, 40);
            velocity.set(0,0,0);
            
            aiController.health = aiController.maxHealth;
            aiController.mesh.position.set(0, 20, -40);
            aiController.pickNewTarget();

            matchTimeRemaining = roundTimeLength;
            updateTimerUI();
        }

        function updateTimerUI() {
            let mins = Math.floor(matchTimeRemaining / 60);
            let secs = matchTimeRemaining % 60;
            document.getElementById('match-timer').innerText = `${mins}:${secs < 10 ? '0' : ''}${secs}`;
        }

        // --- MAP BUILDERS ---
        function buildMap(mapType) {
            const addObj = (geo, mat, pos, rot = [0,0,0]) => {
                // Rivals Style: Flat shading, solid saturated appearance
                mat.flatShading = true;
                mat.roughness = 0.8;
                mat.metalness = 0.1;

                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(...pos); mesh.rotation.set(...rot);
                mesh.receiveShadow = true; mesh.castShadow = true;
                scene.add(mesh); mapColliders.push(mesh);
                return mesh;
            };

            const groundGeo = new THREE.PlaneGeometry(300, 300);
            
            if (mapType === "Playground") {
                scene.background = new THREE.Color(0x87CEEB); 
                const gridTex = generateProceduralTexture('grid', '#228B22', '#1b6b1b'); gridTex.repeat.set(30, 30);
                addObj(groundGeo, new THREE.MeshStandardMaterial({map: gridTex}), [0,0,0], [-Math.PI/2,0,0]); 
                
                addObj(new THREE.BoxGeometry(30, 15, 30), new THREE.MeshStandardMaterial({color: 0xFFFF00}), [0, 7.5, 0]);
                [[12,12], [-12,-12], [12,-12], [-12,12]].forEach(p => {
                    addObj(new THREE.BoxGeometry(4, 4, 4), new THREE.MeshStandardMaterial({color: 0xFF8C00}), [p[0], 17, p[1]]);
                });
                
                const wedgeGeo = new THREE.ConeGeometry(10, 20, 4);
                addObj(wedgeGeo, new THREE.MeshStandardMaterial({color: 0x0000FF}), [-40, 5, 20], [0, Math.PI/4, Math.PI/2]);
                addObj(wedgeGeo, new THREE.MeshStandardMaterial({color: 0x0000FF}), [-40, 5, -20], [0, -Math.PI/4, Math.PI/2]);

                for(let i=-2; i<=2; i++) {
                    addObj(new THREE.CylinderGeometry(2, 2, 25, 16), new THREE.MeshStandardMaterial({color: 0xFF0000}), [40, 12.5, i * 15]);
                }
            } 
            else if (mapType === "SkyPort") {
                scene.background = new THREE.Color(0x0a0a1a); 
                
                const tileTex = generateProceduralTexture('grid', '#eeeeee', '#cccccc'); tileTex.repeat.set(16, 8);
                addObj(new THREE.BoxGeometry(160, 2, 80), new THREE.MeshStandardMaterial({map: tileTex}), [0, -1, 0]);
                
                addObj(new THREE.BoxGeometry(60, 1, 20), new THREE.MeshPhysicalMaterial({color: 0xddddff, transmission: 0.9, opacity: 1, transparent: true}), [0, 0.5, 0]);
                addObj(new THREE.BoxGeometry(10, 8, 2), new THREE.MeshStandardMaterial({color: 0x333333}), [5, 4, 2]);
                addObj(new THREE.BoxGeometry(2, 8, 10), new THREE.MeshStandardMaterial({color: 0x333333}), [9, 4, 6]);
                addObj(new THREE.BoxGeometry(10, 8, 2), new THREE.MeshStandardMaterial({color: 0x333333}), [-5, 4, -2]);
                addObj(new THREE.BoxGeometry(2, 8, 10), new THREE.MeshStandardMaterial({color: 0x333333}), [-9, 4, -6]);

                addObj(new THREE.CylinderGeometry(3, 3, 0.5, 16), new THREE.MeshStandardMaterial({color: 0x00ff00, emissive: 0x005500}), [-50, 0.5, 20]);
                addObj(new THREE.BoxGeometry(20, 1, 20), new THREE.MeshStandardMaterial({color: 0x555555}), [-50, 30, 0]);

                addObj(new THREE.BoxGeometry(80, 1, 5), new THREE.MeshStandardMaterial({color: 0x888888}), [0, -10, 45]);
            }
            else if (mapType === "Temple") {
                scene.background = new THREE.Color(0xF5DEB3); 
                const sandTex = generateProceduralTexture('grid', '#D2B48C', '#c1a57e'); sandTex.repeat.set(30, 30);
                addObj(groundGeo, new THREE.MeshStandardMaterial({map: sandTex}), [0,0,0], [-Math.PI/2,0,0]);
                
                addObj(new THREE.CylinderGeometry(30, 30, 5, 32), new THREE.MeshStandardMaterial({color: 0x008080}), [0, -2.5, 0]);
                addObj(new THREE.CylinderGeometry(2, 2, 15), new THREE.MeshStandardMaterial({color: 0x8B4513}), [0, 5, 0]);
                const leaves = new THREE.Mesh(new THREE.SphereGeometry(10), new THREE.MeshStandardMaterial({color: 0x228B22, transparent:true, opacity:0.8}));
                leaves.position.set(0, 15, 0); scene.add(leaves);

                const brickTex = generateProceduralTexture('bricks', '#aaaaaa', '#888888'); brickTex.repeat.set(2, 2);
                for(let i=0; i<10; i++) addObj(new THREE.BoxGeometry(20, 2, 40), new THREE.MeshStandardMaterial({map: brickTex}), [-40 - (i*2), i*2, 0]);

                addObj(new THREE.BoxGeometry(20, 1, 100), new THREE.MeshStandardMaterial({color: 0x333333}), [50, 0.5, 0]);
            }
            else { 
                scene.background = new THREE.Color(0x222222);
                addObj(groundGeo, new THREE.MeshStandardMaterial({color: 0x444444}), [0,0,0], [-Math.PI/2,0,0]);

                const ribTex = generateProceduralTexture('stripes', '#8b0000', '#6b0000'); ribTex.repeat.set(1, 5);
                const cGeo = new THREE.BoxGeometry(12, 12, 30);
                const cMat = new THREE.MeshStandardMaterial({map: ribTex});
                addObj(cGeo, cMat, [-10, 6, 0]); addObj(cGeo, cMat, [-10, 18, 0]);
                addObj(cGeo, cMat, [10, 6, 0]);  addObj(cGeo, cMat, [10, 18, 0]);

                addObj(new THREE.BoxGeometry(20, 10, 20), new THREE.MeshStandardMaterial({color: 0xcccc00}), [-60, 5, -30]);
                addObj(new THREE.BoxGeometry(16, 10, 16), new THREE.MeshStandardMaterial({color: 0x444444}), [-60, 6, -30]); 
            }

            // ADD UNIVERSAL ARENA BOUNDARIES (TIGHT FIT: +/- 80)
            const boundaryMat = new THREE.MeshStandardMaterial({color: 0x303040, roughness: 1.0, flatShading: true});
            addObj(new THREE.BoxGeometry(160, 100, 10), boundaryMat, [0, 50, -80]);
            addObj(new THREE.BoxGeometry(160, 100, 10), boundaryMat, [0, 50, 80]);
            addObj(new THREE.BoxGeometry(10, 100, 160), boundaryMat, [-80, 50, 0]);
            addObj(new THREE.BoxGeometry(10, 100, 160), boundaryMat, [80, 50, 0]);

            // ADD RAMPS FOR TRAVERSAL
            const rampMat = new THREE.MeshStandardMaterial({color: 0xff007f, flatShading: true});
            addObj(new THREE.BoxGeometry(20, 2, 40), rampMat, [30, 5, 30], [Math.PI/6, 0, 0]);
            addObj(new THREE.BoxGeometry(20, 2, 40), rampMat, [-30, 5, -30], [-Math.PI/6, 0, 0]);
            
            // Apply atmosphere fog for aesthetics
            scene.fog = new THREE.FogExp2(scene.background, 0.003);
        }

        // --- SMART AI CLASS ---
        class SmartAI {
            constructor(dummyMesh) {
                this.mesh = dummyMesh; this.health = 100; this.maxHealth = 100; this.state = "pursue"; 
                this.dashCooldown = 0; this.shootCooldown = 0; this.grenadeCooldown = 500;
                this.moveSpeed = 0.12; 
                this.targetPos = new THREE.Vector3(); this.pickNewTarget();
                
                this.hpUI = document.createElement('div');
                this.hpUI.style.position = 'absolute'; this.hpUI.style.width = '50px'; this.hpUI.style.height = '5px';
                this.hpUI.style.background = 'red'; this.hpUI.style.border = '1px solid black';
                document.getElementById('ui-layer').appendChild(this.hpUI);
            }

            pickNewTarget() { this.targetPos.set((Math.random()-0.5)*80, 2.5, (Math.random()-0.5)*80); }

            takeDamage(amt) {
                this.health -= amt; spawnParticles(this.mesh.position, 10, 'spark', 0xff007f);
                this.dashCooldown = 0; // Force dodge/dash upon hit
                if(this.health <= 0) this.die();
            }

            die() {
                pScore++; document.getElementById('p-score').innerText = pScore;
                resetRound(); 
            }

            update(playerPos, cameraObj) {
                if(this.dashCooldown > 0) this.dashCooldown--;
                if(this.shootCooldown > 0) this.shootCooldown--;
                if(this.grenadeCooldown > 0) this.grenadeCooldown--;

                const distToPlayer = this.mesh.position.distanceTo(playerPos);

                const screenPos = this.mesh.position.clone().add(new THREE.Vector3(0, 4, 0));
                screenPos.project(cameraObj);
                if (screenPos.z < 1) {
                    this.hpUI.style.display = 'block';
                    this.hpUI.style.left = `${(screenPos.x * .5 + .5) * window.innerWidth - 25}px`;
                    this.hpUI.style.top = `${(-screenPos.y * .5 + .5) * window.innerHeight}px`;
                    this.hpUI.style.width = `${(this.health/this.maxHealth) * 50}px`;
                } else { this.hpUI.style.display = 'none'; }

                // Check Line of Sight
                const dirToPlayer = playerPos.clone().sub(this.mesh.position).normalize();
                bulletRaycaster.set(this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)), dirToPlayer);
                let hits = bulletRaycaster.intersectObjects(mapColliders);
                let hasLOS = true;
                if (hits.length > 0 && hits[0].distance < distToPlayer) hasLOS = false;

                if (distToPlayer < 120 && hasLOS) {
                    this.state = "attack";
                    this.mesh.lookAt(playerPos.x, this.mesh.position.y, playerPos.z);
                    
                    // Dodge / Dash
                    if (this.dashCooldown <= 0 && Math.random() < 0.05) {
                        const dashDir = new THREE.Vector3((Math.random()-0.5), 0, (Math.random()-0.5)).normalize().multiplyScalar(15);
                        this.mesh.position.add(dashDir); this.dashCooldown = 150; 
                        spawnParticles(this.mesh.position, 20, 'smoke', 0xffffff);
                    }

                    // Jump randomly
                    if (Math.random() < 0.02 && this.mesh.position.y < 5) {
                        this.mesh.position.y += 10;
                    }

                    if (this.shootCooldown <= 0) {
                        this.shootAtPlayer(playerPos);
                        this.shootCooldown = Math.floor(Math.random() * 30) + 15; 
                    }

                    if (this.grenadeCooldown <= 0 && distToPlayer > 20) {
                        this.throwGrenade(playerPos); this.grenadeCooldown = 600; 
                    }

                    const strafe = new THREE.Vector3(1, 0, 0).applyQuaternion(this.mesh.quaternion).multiplyScalar(Math.sin(performance.now()*0.005) * this.moveSpeed * 2);
                    this.mesh.position.add(strafe);
                } else {
                    // Smart pathing: pursue player
                    this.state = "pursue";
                    this.targetPos = playerPos.clone();
                    this.mesh.lookAt(this.targetPos.x, this.mesh.position.y, this.targetPos.z);
                    const dir = this.targetPos.clone().sub(this.mesh.position).normalize();
                    this.mesh.position.add(dir.multiplyScalar(this.moveSpeed * 1.5));
                }

                // AI Wall & Ramp Collision
                const aiOrigin = this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0));
                
                // Vertical (Gravity/Ramps)
                bulletRaycaster.set(aiOrigin, new THREE.Vector3(0, -1, 0));
                let gHits = bulletRaycaster.intersectObjects(mapColliders);
                let groundY = 2.5; 
                if (gHits.length > 0 && gHits[0].distance < 20) groundY = gHits[0].point.y + 2.5;

                if (this.mesh.position.y > groundY) {
                    this.mesh.position.y -= 0.5; // fall
                } else if (this.mesh.position.y < groundY) {
                    this.mesh.position.y = groundY; // snap up ramp
                }

                // Horizontal Walls
                const dirs = [new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0), new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)];
                for(let d of dirs) {
                    bulletRaycaster.set(aiOrigin, d);
                    let wHits = bulletRaycaster.intersectObjects(mapColliders);
                    if(wHits.length > 0 && wHits[0].distance < 2.0) {
                        if(Math.abs(wHits[0].face.normal.y) < 0.5) { // Ignore floors/ramps for wall push
                            let overlap = 2.0 - wHits[0].distance;
                            this.mesh.position.x += wHits[0].face.normal.x * overlap;
                            this.mesh.position.z += wHits[0].face.normal.z * overlap;
                        }
                    }
                }
            }

            shootAtPlayer(playerPos) {
                const bGeo = new THREE.BoxGeometry(0.1, 0.1, 1.2);
                const bMat = new THREE.MeshBasicMaterial({color: 0xff0000}); 
                const b = new THREE.Mesh(bGeo, bMat);
                const target = playerPos.clone().add(new THREE.Vector3((Math.random()-0.5)*1.5, (Math.random()-0.5)*1.5, (Math.random()-0.5)*1.5));
                const dir = target.sub(this.mesh.position.clone().add(new THREE.Vector3(0,2,0))).normalize();
                
                b.position.copy(this.mesh.position).add(new THREE.Vector3(0,2,0)).add(dir.multiplyScalar(2));
                b.lookAt(b.position.clone().add(dir));
                b.userData = { velocity: dir.multiplyScalar(3), damage: 15 };
                scene.add(b); enemyBullets.push(b);
            }

            throwGrenade(playerPos) {
                const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const mat = new THREE.MeshStandardMaterial({color: 0xff4400}); 
                const mesh = new THREE.Mesh(geo, mat);
                const dir = playerPos.clone().sub(this.mesh.position).normalize();
                mesh.position.copy(this.mesh.position).add(new THREE.Vector3(0,3,0));
                mesh.userData = { vel: dir.multiplyScalar(15).add(new THREE.Vector3(0, 10, 0)), type: "grenade", name: "Enemy-Fire", grounded: false };
                scene.add(mesh); throwables.push(mesh);
            }
        }

        function initGame() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer, nicer shadows
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0x404040, 0.7));
            const sun = new THREE.DirectionalLight(0xffffff, 1.2); // Brighter sun
            sun.position.set(100, 100, 50); sun.castShadow = true; scene.add(sun);

            buildMap(selectedMap || "Playground");

            controls = new PointerLockControls(camera, document.body); controls.lock();

            dummy = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CapsuleGeometry(1.2, 3, 4, 8), new THREE.MeshStandardMaterial({color: 0xff007f}));
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.7), new THREE.MeshStandardMaterial({color: 0x555555}));
            head.position.y = 2.5; dummy.add(body, head);
            dummy.position.set(0, 20, -20); scene.add(dummy);

            aiController = new SmartAI(dummy);

            const lineGroup = new THREE.Group();
            for(let i=0; i<20; i++) {
                const line = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, 2), new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0}));
                line.position.set((Math.random()-0.5)*15, (Math.random()-0.5)*10, -5); lineGroup.add(line); motionLines.push(line);
            }
            camera.add(lineGroup);

            const hudSlots = document.getElementById('hud-slots');
            selectedItems.forEach((item, i) => {
                const slot = document.createElement('div'); slot.className = `slot ${i === 0 ? 'active' : ''}`;
                slot.id = `hud-slot-${i}`; slot.setAttribute('data-key', i + 1); slot.innerText = item; hudSlots.appendChild(slot);
            });

            weaponGroup = new THREE.Group(); camera.add(weaponGroup); scene.add(controls.getObject());
            controls.getObject().position.set(0, 50, 40);

            // Match Timer Interval
            setInterval(() => {
                if(matchTimeRemaining > 0) {
                    matchTimeRemaining--; updateTimerUI();
                } else if(matchTimeRemaining === 0) {
                    resetRound();
                }
            }, 1000);

            setupInputs(); updateWeaponModel(); updateAmmoUI(); animate();
            
            setTimeout(() => { document.getElementById('round-announcement').style.opacity = 0; }, 2000);
            document.getElementById('round-announcement').style.opacity = 1;
        }

        class DamageNumber {
            constructor(pos, value) {
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 128; const ctx = canvas.getContext('2d');
                ctx.font = 'bold 60px Montserrat'; ctx.fillStyle = value > 50 ? '#ff0000' : '#ffffff';
                ctx.textAlign = 'center'; ctx.fillText(Math.floor(value), 64, 64);
                this.sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
                this.sprite.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5), 2, (Math.random()-0.5)));
                this.sprite.scale.set(2, 2, 2); this.life = 1.0; scene.add(this.sprite);
            }
            update() {
                this.life -= 0.02; this.sprite.position.y += 0.05; this.sprite.material.opacity = this.life;
                if(this.life <= 0) { scene.remove(this.sprite); return false; }
                return true;
            }
        }

        function setupInputs() {
            window.oncontextmenu = (e) => e.preventDefault(); 
            window.onkeydown = (e) => {
                if(e.code === 'KeyW') moveFwd = true; if(e.code === 'KeyS') moveBwd = true;
                if(e.code === 'KeyA') moveL = true; if(e.code === 'KeyD') moveR = true;
                
                // DASH LOGIC FIX - Reduced push to prevent teleporting, added cooldown
                if((e.code === 'ControlLeft' || e.code === 'ShiftLeft') && !isSliding) { 
                    isSliding = true; 
                    if(isGrounded && performance.now() - lastDashTime > 800) {
                        const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                        forward.y = 0; forward.normalize();
                        velocity.add(forward.multiplyScalar(150)); // SAFE dash impulse
                        lastDashTime = performance.now();
                    }
                }
                if(e.code === 'Space' && isGrounded) velocity.y += 35; 
                if(e.code === 'KeyR') reload();
                if(['1','2','3','4'].includes(e.key)) { activeWeaponIndex = parseInt(e.key) - 1; isScoping = false; updateWeaponModel(); updateAmmoUI(); }
            };
            window.onkeyup = (e) => {
                if(e.code === 'KeyW') moveFwd = false; if(e.code === 'KeyS') moveBwd = false;
                if(e.code === 'KeyA') moveL = false; if(e.code === 'KeyD') moveR = false;
                if(e.code === 'ControlLeft' || e.code === 'ShiftLeft') isSliding = false;
            };
            window.onmousedown = (e) => { 
                if(!controls.isLocked) return;
                if(e.button === 0) shoot(); 
                if(e.button === 2 && (activeWeaponIndex === 0 || activeWeaponIndex === 1)) isScoping = true;
            };
            window.onmouseup = (e) => { if(e.button === 2) isScoping = false; };
        }

        function updateAmmoUI() {
            const config = WEAPON_CONFIG[selectedItems[activeWeaponIndex]];
            const ammoText = document.getElementById('ammo-text');
            if (!config) return;
            if (activeWeaponIndex === 2) {
                ammoText.innerText = canShoot ? "READY" : "COOLDOWN"; ammoText.style.color = canShoot ? "#00ff00" : "#ff0000";
            } else if (config.type === "laser") {
                ammoText.innerText = `HEAT: ${Math.floor(laserHeat)}%`; ammoText.style.color = laserHeat > 80 ? "#ff0000" : "#00d2d3";
            } else if (config.type === "melee") { ammoText.innerText = "READY"; } else {
                ammoText.innerText = isReloading ? "RELOADING..." : `${ammoState[activeWeaponIndex]} / ${config.mag}`; ammoText.style.color = "white";
            }
        }

        function reload() {
            const config = WEAPON_CONFIG[selectedItems[activeWeaponIndex]];
            if (!config || activeWeaponIndex === 2 || config.type === "melee" || isReloading || ammoState[activeWeaponIndex] === config.mag) return;
            isReloading = true; updateAmmoUI(); weaponGroup.rotation.x = 0.5;
            setTimeout(() => { ammoState[activeWeaponIndex] = config.mag; isReloading = false; weaponGroup.rotation.x = 0; updateAmmoUI(); }, config.reload);
        }

        function updateWeaponModel() {
            while(weaponGroup.children.length > 0) weaponGroup.remove(weaponGroup.children[0]);
            document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
            const hudSlot = document.getElementById(`hud-slot-${activeWeaponIndex}`); if(hudSlot) hudSlot.classList.add('active');

            const config = WEAPON_CONFIG[selectedItems[activeWeaponIndex]] || { color: 0xffffff };
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 1.4), new THREE.MeshStandardMaterial({color: config.color, flatShading: true}));
            const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.8), new THREE.MeshStandardMaterial({color: 0x111111, flatShading: true})); barrel.position.z = -0.8;
            const mag = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.25), new THREE.MeshStandardMaterial({color: 0x000000, flatShading: true})); mag.position.set(0, -0.3, -0.2);
            const weaponInner = new THREE.Group(); weaponInner.add(body, barrel, mag);
            
            if(config.type === "melee") { mag.visible = false; barrel.scale.set(0.5, 3, 0.1); barrel.position.set(0, 0, -0.8); }
            if(activeWeaponIndex === 2) { barrel.visible = false; body.scale.set(1, 1, 0.5); }

            weaponInner.position.set(0.8, -0.7, -1.2); weaponGroup.add(weaponInner);
        }

        class Particle {
            constructor(pos, type, color) {
                this.pos = pos.clone(); this.type = type; this.life = 1.0;
                if (type === 'fire') { this.vel = new THREE.Vector3((Math.random()-0.5)*4, Math.random()*8, (Math.random()-0.5)*4); this.decay = 0.01 + Math.random()*0.02; this.size = 2 + Math.random(); } 
                else if (type === 'smoke') { this.vel = new THREE.Vector3((Math.random()-0.5)*5, Math.random()*2, (Math.random()-0.5)*5); this.decay = 0.005; this.size = 5 + Math.random()*5; } 
                else if (type === 'spark') { this.vel = new THREE.Vector3((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*20); this.decay = 0.05; this.size = 0.5; } 
                else if (type === 'flash') { this.vel = new THREE.Vector3(0,0,0); this.decay = 0.1; this.size = 20; } 
                else if (type === 'flare_core') { this.vel = new THREE.Vector3((Math.random()-0.5)*2, Math.random()*15, (Math.random()-0.5)*2); this.decay = 0.02; this.size = 4; }

                this.mesh = new THREE.Sprite(new THREE.SpriteMaterial({ map: type === 'spark' ? sparkTex : smokeTex, color: color, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending }));
                this.mesh.position.copy(this.pos); this.mesh.scale.set(this.size, this.size, this.size); scene.add(this.mesh);
            }
            update() {
                this.life -= this.decay; this.pos.addVectors(this.pos, this.vel.clone().multiplyScalar(0.016)); this.mesh.position.copy(this.pos);
                if (this.type === 'fire' || this.type === 'flare_core') { this.mesh.scale.set(this.size * this.life, this.size * this.life, 1); this.mesh.material.opacity = this.life; } 
                else if (this.type === 'smoke') { this.mesh.scale.multiplyScalar(1.01); this.mesh.material.opacity = this.life * 0.5; } 
                else { this.mesh.material.opacity = this.life; }
            }
        }

        function spawnParticles(pos, count, type, color) { for(let i=0; i<count; i++) particles.push(new Particle(pos, type, color)); }

        async function shoot() {
            const name = selectedItems[activeWeaponIndex]; const config = WEAPON_CONFIG[name];
            if(!canShoot || isReloading || !config) return;

            if (activeWeaponIndex === 2) { useTactical(name, config); return; }

            if (config.type === "melee") {
                canShoot = false; weaponGroup.children[0].rotation.x = -1.2;
                if (controls.getObject().position.distanceTo(dummy.position) < 8) {
                    damageTexts.push(new DamageNumber(dummy.position.clone().add(new THREE.Vector3(0,2,0)), config.damage)); aiController.takeDamage(config.damage);
                }
                setTimeout(() => { weaponGroup.children[0].rotation.x = 0; canShoot = true; }, 1000 * (60 / config.rpm)); return;
            }

            if (config.type !== "laser") { if (ammoState[activeWeaponIndex] <= 0) { reload(); return; } ammoState[activeWeaponIndex]--; }
            if (config.type === "laser") { if (laserHeat >= 100) return; laserHeat += 15; }

            canShoot = false; const shots = config.type === "burst" ? 3 : 1;
            for(let i=0; i<shots; i++) {
                spawnBullet(config.damage); weaponGroup.position.z += 0.1;
                if(config.kick) velocity.z += config.kick * 10;
                if(shots > 1) await new Promise(r => setTimeout(r, 80));
            }
            updateAmmoUI(); setTimeout(() => { canShoot = true; weaponGroup.position.z = 0; updateAmmoUI(); }, 60000 / config.rpm);
        }

        function useTactical(name, config) {
            canShoot = false; updateAmmoUI();
            if(config.type === "self") { if(name === "Stim-Shot") { health = 100; document.getElementById('hp-bar').style.width = '100%'; spawnParticles(controls.getObject().position, 50, 'spark', 0x00ff00); } } 
            else { spawnThrowable(name, config); }
            setTimeout(() => { canShoot = true; updateAmmoUI(); }, config.cooldown);
        }

        function spawnThrowable(name, config) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), new THREE.MeshStandardMaterial({color: config.color}));
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir); mesh.position.copy(camera.position).add(dir);
            mesh.userData = { vel: dir.multiplyScalar(25).add(new THREE.Vector3(0, 5, 0)), type: "grenade", config: config, name: name, grounded: false };
            scene.add(mesh); throwables.push(mesh);
        }

        function detonate(obj) {
            const name = obj.userData.name; const config = obj.userData.config || {aoeDmg: 15}; const pos = obj.position.clone();
            if (name === "Molotov" || name === "Enemy-Fire") {
                const fireLight = new THREE.PointLight(0xff4400, 15, 200); fireLight.position.copy(pos); scene.add(fireLight);
                activeAOEs.push({ pos, type: 'fire', color: 0xff4400, life: 30 * 60, light: fireLight, damage: config.aoeDmg, radius: 45 }); // WIDER
            } 
            else if (name === "Flare Gun") {
                const flareLight = new THREE.PointLight(0xff0000, 20, 250); flareLight.position.copy(pos); scene.add(flareLight);
                activeAOEs.push({ pos, type: 'flare_core', color: 0xff0000, life: 30 * 60, light: flareLight, damage: config.aoeDmg, radius: 50 }); // WIDER
            }
            else if (name === "Flashbang") {
                spawnParticles(pos, 50, 'spark', 0xffffff);
                if (pos.distanceTo(controls.getObject().position) < 120) { // FIXED FLASHBANG RANGE
                    const overlay = document.getElementById('flash-overlay'); overlay.style.opacity = 1; overlay.style.transition = 'opacity 0.05s';
                    setTimeout(() => { overlay.style.transition = 'opacity 3s'; overlay.style.opacity = 0; }, 100);
                }
            }
            else if (name === "Smoke Screen") { spawnParticles(pos, 400, 'smoke', 0xcccccc); }
            else if (name === "Shock Trap") {
                spawnParticles(pos, 200, 'spark', 0x00ffff);
                const light = new THREE.PointLight(0x00ffff, 5, 200); light.position.copy(pos); scene.add(light);
                activeAOEs.push({ pos, type: 'spark', color: 0x00ffff, life: 5 * 60, light: light, damage: config.aoeDmg, radius: 40 }); // WIDER
            }
            else if (name === "Decoy Grenade") { spawnParticles(pos, 50, 'spark', 0xffaa00); }
            scene.remove(obj);
        }

        function spawnBullet(dmg) {
            const b = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 1.2), new THREE.MeshBasicMaterial({color: 0xffff00}));
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            b.position.copy(camera.position).add(dir.multiplyScalar(1)); b.lookAt(camera.position.clone().add(dir).add(dir));
            b.userData = { velocity: dir.clone().multiplyScalar(5), damage: dmg || 10 }; 
            scene.add(b); bullets.push(b);
        }

        function takePlayerDamage(amt) {
            health -= amt; document.getElementById('hp-bar').style.width = `${Math.max(0, health)}%`;
            if (health <= 0) { eScore++; document.getElementById('e-score').innerText = eScore; resetRound(); }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now(); const delta = 0.016;

            if (aiController) aiController.update(controls.getObject().position, camera);

            if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta; velocity.y -= 9.8 * 12.0 * delta; 
                direction.z = Number(moveFwd) - Number(moveBwd); direction.x = Number(moveR) - Number(moveL); direction.normalize();

                let speed = (isSliding && isGrounded) ? 900 : 500; 
                if (moveFwd || moveBwd) velocity.z -= direction.z * speed * delta;
                if (moveL || moveR) velocity.x -= direction.x * speed * delta;

                // MOVE
                controls.moveRight(-velocity.x * delta); 
                controls.moveForward(-velocity.z * delta); 
                controls.getObject().position.y += (velocity.y * delta);

                // CONTINUOUS RAYCAST COLLISION (PLAYER)
                
                // 1. Ground & Ramps
                const pOrigin = controls.getObject().position.clone();
                bulletRaycaster.set(new THREE.Vector3(pOrigin.x, pOrigin.y, pOrigin.z), new THREE.Vector3(0, -1, 0));
                let gHits = bulletRaycaster.intersectObjects(mapColliders);
                
                let floorY = 5; // default eye level
                if (gHits.length > 0 && gHits[0].distance < 15) {
                    floorY = gHits[0].point.y + 5; // snap to slope + player height
                }

                if (controls.getObject().position.y <= floorY) { 
                    velocity.y = Math.max(0, velocity.y); 
                    controls.getObject().position.y = floorY; 
                    isGrounded = true; 
                } else { 
                    isGrounded = false; 
                }

                // 2. Horizontal Walls (FIXED: Stop Wall Phasing / Random Teleporting)
                const hOrigin = new THREE.Vector3(controls.getObject().position.x, controls.getObject().position.y - 2.5, controls.getObject().position.z);
                const hDirs = [
                    new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0), 
                    new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1),
                    new THREE.Vector3(1,0,1).normalize(), new THREE.Vector3(-1,0,1).normalize(),
                    new THREE.Vector3(1,0,-1).normalize(), new THREE.Vector3(-1,0,-1).normalize()
                ];
                
                for (let dir of hDirs) {
                    bulletRaycaster.set(hOrigin, dir);
                    let hits = bulletRaycaster.intersectObjects(mapColliders);
                    if (hits.length > 0 && hits[0].distance < 1.5) {
                        // Ignore floors/ramps for horizontal pushing
                        if (Math.abs(hits[0].face.normal.y) < 0.6) {
                            let overlap = 1.5 - hits[0].distance;
                            controls.getObject().position.x += hits[0].face.normal.x * overlap;
                            controls.getObject().position.z += hits[0].face.normal.z * overlap;

                            // KILL VELOCITY pushing into the wall to stabilize physics
                            if (velocity.x * hits[0].face.normal.x < 0) velocity.x = 0;
                            if (velocity.z * hits[0].face.normal.z < 0) velocity.z = 0;
                        }
                    }
                }
            }

            const isSprinting = isSliding && isGrounded && (moveFwd || moveL || moveR);
            motionLines.forEach((l) => {
                if(isSprinting) { l.material.opacity = 0.5; l.scale.z = 2 + Math.random() * 5; l.position.z += 1; if(l.position.z > 0) l.position.z = -15; } 
                else { l.material.opacity = THREE.MathUtils.lerp(l.material.opacity, 0, 0.1); }
            });

            for(let i = damageTexts.length - 1; i >= 0; i--) { if(!damageTexts[i].update()) damageTexts.splice(i, 1); }

            // PLAYER BULLETS
            for(let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                bulletRaycaster.set(b.position, b.userData.velocity.clone().normalize());
                let hits = bulletRaycaster.intersectObjects(mapColliders);
                if (hits.length > 0 && hits[0].distance < b.userData.velocity.length()) {
                    spawnParticles(hits[0].point, 5, 'spark', 0xaaaaaa);
                    scene.remove(b); bullets.splice(i, 1); continue;
                }

                b.position.add(b.userData.velocity); b.scale.z = 3.5; 

                if(b.position.distanceTo(dummy.position) < 3.5) { 
                    damageTexts.push(new DamageNumber(b.position, b.userData.damage));
                    spawnParticles(b.position, 5, 'spark', 0xff007f);
                    aiController.takeDamage(b.userData.damage);
                    scene.remove(b); bullets.splice(i, 1); continue;
                }
                if(b.position.distanceTo(camera.position) > 400) { scene.remove(b); bullets.splice(i, 1); }
            }

            // ENEMY BULLETS
            for(let i = enemyBullets.length - 1; i >= 0; i--) {
                const b = enemyBullets[i];
                bulletRaycaster.set(b.position, b.userData.velocity.clone().normalize());
                let hits = bulletRaycaster.intersectObjects(mapColliders);
                if (hits.length > 0 && hits[0].distance < b.userData.velocity.length()) {
                    spawnParticles(hits[0].point, 5, 'spark', 0xaaaaaa);
                    scene.remove(b); enemyBullets.splice(i, 1); continue;
                }

                b.position.add(b.userData.velocity); b.scale.z = 3.5; 

                if(b.position.distanceTo(controls.getObject().position) < 3.0) { 
                    takePlayerDamage(b.userData.damage);
                    scene.remove(b); enemyBullets.splice(i, 1); continue;
                }
                if(b.position.distanceTo(dummy.position) > 400) { scene.remove(b); enemyBullets.splice(i, 1); }
            }

            // AOE EFFECTS (WIDER SPREAD)
            for(let i = activeAOEs.length - 1; i >= 0; i--) {
                const aoe = activeAOEs[i];
                
                if(Math.random() > 0.3) {
                    let spread = aoe.radius ? aoe.radius * 0.8 : 2;
                    spawnParticles(aoe.pos.clone().add(new THREE.Vector3((Math.random()-0.5)*spread, Math.random()*2, (Math.random()-0.5)*spread)), 2, aoe.type, aoe.color);
                }
                
                if (aoe.damage) {
                    let radius = aoe.radius || 8;
                    if (aoe.pos.distanceTo(dummy.position) < radius && aoe.life % 10 === 0) { damageTexts.push(new DamageNumber(dummy.position.clone().add(new THREE.Vector3(0,2,0)), aoe.damage)); aiController.takeDamage(aoe.damage); }
                    if (aoe.pos.distanceTo(controls.getObject().position) < radius && aoe.life % 10 === 0) takePlayerDamage(aoe.damage); 
                }

                aoe.life--; if(aoe.life <= 0) { scene.remove(aoe.light); activeAOEs.splice(i, 1); }
            }

            // THROWABLES COLLISION FIX (Check velocity direction, not just downwards)
            for(let i = throwables.length - 1; i >= 0; i--) {
                const t = throwables[i]; t.userData.vel.y -= 0.5; t.position.add(t.userData.vel.clone().multiplyScalar(0.016));
                const speed = t.userData.vel.length(); t.scale.set(1, 1, 1 + (speed * 0.05)); t.lookAt(t.position.clone().add(t.userData.vel));
                
                const stepDist = speed * 0.016;
                
                // Raycast in the exact direction the throwable is flying
                bulletRaycaster.set(t.position, t.userData.vel.clone().normalize());
                let hits = bulletRaycaster.intersectObjects(mapColliders);
                
                if (hits.length > 0 && hits[0].distance <= stepDist + 0.5) {
                    if (!t.userData.grounded) {
                        t.userData.grounded = true;
                        t.position.copy(hits[0].point); // Lock to surface hit
                        setTimeout(() => { if(throwables.includes(t)) { detonate(t); const idx = throwables.indexOf(t); if(idx > -1) throwables.splice(idx, 1); } }, 100);
                    }
                } else {
                    // Fallback downward check just in case gravity pulled it past a floor
                    bulletRaycaster.set(t.position, new THREE.Vector3(0, -1, 0));
                    let floorHits = bulletRaycaster.intersectObjects(mapColliders);
                    if (floorHits.length > 0 && floorHits[0].distance < 0.5 && !t.userData.grounded) {
                        t.userData.grounded = true;
                        t.position.y = floorHits[0].point.y + 0.3;
                        setTimeout(() => { if(throwables.includes(t)) { detonate(t); const idx = throwables.indexOf(t); if(idx > -1) throwables.splice(idx, 1); } }, 100);
                    }
                }
            }

            for(let i = particles.length - 1; i >= 0; i--) { particles[i].update(); if(particles[i].life <= 0) { scene.remove(particles[i].mesh); particles.splice(i, 1); } }

            let baseFov = (isSliding && isGrounded) ? 100 : 75; const targetFov = isScoping ? 40 : baseFov;
            camera.fov = THREE.MathUtils.lerp(camera.fov, targetFov, 0.2); camera.updateProjectionMatrix();
            if (weaponGroup.children[0]) {
                const targetWeaponPos = isScoping ? new THREE.Vector3(0, -0.45, -0.8) : new THREE.Vector3(0.8, -0.7, -1.2);
                weaponGroup.children[0].position.lerp(targetWeaponPos, 0.2);
            }
            weaponGroup.position.y = Math.sin(time * 0.005) * 0.01; weaponGroup.position.x = Math.cos(time * 0.003) * 0.01;
            renderer.render(scene, camera);
        }

        window.onresize = () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
    </script>
</body>
</html>
